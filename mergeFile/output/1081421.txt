#pragma once
#pragma once
#include<vector>
#include<iostream>
#include <exception>
#include<stdexcept>
using namespace std;
class Error : public exception
{
public:
	Error() :exception("out of range") {};
};
template <typename T>
class MyArray :public Error
{
	/*template <typename T>*/
	friend ostream &operator << (ostream& cout, const  MyArray<T>&right) {
		for (int i = 0; i < right.getSize(); i++) {
			cout << right.n[i] << " ";
		}
		return cout;
	}
public:
	MyArray() {
		n = new T[capacity]();
	};
	MyArray(int a);
	MyArray(int size, T value);
	MyArray(const MyArray&);
	~MyArray();
	const MyArray& operator = (const MyArray&);
	bool operator ==(const MyArray&);
	bool operator !=(const MyArray&);
	MyArray operator +(const MyArray&);
	MyArray operator +=(const MyArray&);
	T & operator[](int);
	T operator[](int)const;
	int getSize() const;
	int getCapacity()const;
	void resize(int size, T item);
	void reserve(int size);
	void shrink_to_fit();
	void clear();
	bool isEmpty();
	T& at(int);
	T& at(int)const;
private:
	int size = 0;
	int capacity = 10;
	T *n;
};
template <typename T>
MyArray<T>::MyArray(int a) {
	a = capacity;
	n = new T[capacity]();
}//OK
template <typename T>
MyArray<T>::MyArray(int num, T value) {
	if (num < 10) {
		n = new T[capacity]();
		resize(num, value);
	}
	else {
		while (capacity < num)
			capacity *= 2;
		size = num;
		n = new T[capacity]();
		for (int i = 0; i < num; i++)
			n[i] = value;
	}
}
template <typename T>
MyArray<T>::~MyArray() {
	delete[]n;
}
template <typename T>
MyArray<T>::MyArray(const MyArray<T> &copy) {
	capacity = copy.capacity;
	size = copy.size;
	n = new T[(capacity)]();
	for (int i = 0; i < size; i++)
		n[i] = copy[i];
}
template <typename T>
bool MyArray<T>:: operator==(const MyArray<T>&right) {
	if (size != right.size)
		return false;
	if (capacity != right.capacity)
		return false;
	for (int i = 0; i < size; i++) {
		if (n[i] != right.n[i])
			return false;
	}
	return true;
}
template <typename T>
bool  MyArray<T>::operator!=(const MyArray<T>&right)
{
	return !(*this == right);
}
template <typename T>
const MyArray<T>&MyArray<T>::operator=(const MyArray<T>&right)
{
	capacity = right.capacity;
	size = right.size;
	delete[] n;
	n = new T[(capacity)]();//rase the space first
	for (int i = 0; i < size; i++)
		n[i] = right.n[i];
	return *this;
}
//template <typename T>
//ostream &operator << (ostream& cout, const  MyArray<T>&right) {
//	for (int i = 0; i < right.getsize(); i++) {
//		cout << right.n[i] << " ";
//	}
//	cout << endl;
//	return cout;
//}

template <typename T>
T& MyArray<T>::operator[](int data) {
	return n[data];
}
template <typename T>
T MyArray<T>::operator[](int data)const {
	return n[data];
}
template <typename T>
int  MyArray<T>::getSize()const
{
	return size;
}
template <typename T>
int MyArray<T>::getCapacity()const
{
	return capacity;
}
template <typename T>
void MyArray<T>::resize(int a, T value)
{
	if (a < size) {
		capacity = 10;
		while (a > capacity) {
			reserve(capacity * 2);
		}
		for (int i = 0; i < 5; i++)
			n[i] = value;
		for (int i = a; i < capacity; i++)
		{
			n[i] = NULL;
		}
		size = a;
	}
	else {
		int temp = size;

		while (a > capacity) {
			reserve(capacity * 2);
		}
		for (int i = temp; i < a; i++) {
			n[i] = value;
		}
		size = a;
	}
}
template <typename T>
void MyArray<T>::reserve(int a) {
	capacity = a;
	T* temp = new T[capacity]();
	for (int i = 0; i < size; i++)
		temp[i] = n[i];
	delete[]n;
	n = temp;
}
template <typename T>
MyArray<T>MyArray<T>:: operator +(const MyArray<T>&right) {
	MyArray<T> temp;
	temp = *this;
	temp.resize(temp.getSize() + right.getSize(), 0);
	for (int a = 0, i = size; i < size + right.size; i++, a++) {
		temp[i] = right[a];

	}
	return temp;

}
template <typename T>
MyArray<T>MyArray<T>:: operator +=(const MyArray<T>&right) {
	/*resize(getsize() + right.getsize(), 0);
	for (int a = 0, i = getsize(); a < right.getsize(); i++, a++) {
		n[i] = right[a];
	}
	return *this;*/
	MyArray<T> temp;
	temp = *this;
	temp.resize(temp.getSize() + right.getSize(), 0);
	for (int a = 0, i = size; i < size + right.size; i++, a++) {
		temp[i] = right[a];
	}

	*this = temp;
	return *this;
}
template <typename T>
void MyArray<T>::shrink_to_fit() {
	MyArray temp;
	temp = *this;
	capacity = size;
	delete[] n;
	n = new T[capacity]();
	for (int i = 0; i < capacity; i++)
		n[i] = temp[i];

}
template <typename T>
void MyArray<T>::clear() {
	delete[] n;
	n = new T[capacity]();
	size = 0;
}
template <typename T>
bool MyArray<T>::isEmpty() {
	/*for (int i = 0; i < size; i++)
	{
		if (n[i] != ' ')
			return false;
	}*/
	if (size == 0)
		return true;
	else
		return false;
}
template <typename T>
T& MyArray<T>::at(int num) {

	if (num < 0 || num >= size)
	{
		throw  Error::Error();
	}
	return n[num];
}
template <typename T>
T& MyArray<T>::at(int num)const {
	if (num < 0 || num >= size)
	{
		throw Error::Error();
	}
	return n[num];

}

#ifndef PG2MyString_H
#define PG2MyString_H
#include"s1081421_MyArray.h"
#include<vector>
#include<iostream>
#include <exception>
#include<stdexcept>
using namespace std;
class MyString :public MyArray<char> {
	friend istream &operator>>(istream &input, MyString &right) {

		char *tmp = new char[10000]();
		input >> tmp;
		/*for (int i = 0; tmp[i] != '\0'; i++)
			if (tmp[i] == '\0')
				right.resize(i,' ');*/
		int i = 0;
		while (tmp[i] != '\0')
			i++;
		right.resize(i, ' ');
		for (int i = 0; i < right.getSize(); i++) {
			right.at(i) = tmp[i];
		}
		return cin;
	}
public:
	MyString();
	MyString(const MyString&str);
	MyString(const MyString&str, int pos, int msize);
	MyString(const char *s);
	~MyString();
	static const int msize = -1;
	MyString& append(const MyString&);
	MyString substr(int po, int len = msize)const;
	MyString& insert(int po, const MyString&);
	MyString& insert(int po, const MyString&, int subpos, int sublen);
	MyString& erase(int po, int len);
	int find(const MyString&, int pos = 0)const;
	int find_first_of(const MyString&, int pos = 0)const;
private:
};
MyString::MyString() :MyArray<char>() {
}
MyString::MyString(const MyString& right) : MyArray<char>(right) {

}
MyString::MyString(const MyString&str, int pos, int len) : MyArray<char>(10) {
	*this = str.substr(pos, len);
}
MyString::MyString(const char *s) 
:MyArray(10)
{
	int x = 0;
	while (1) {
		if (s[x] == '\0')
			break;
		x++;
	}
	int len = x;
	resize(len, ' ');
	for (int i = 0; i < len; i++) {
		at(i) = s[i];
	}
}
MyString::~MyString() {

}
MyString&MyString:: append(const MyString& right) {
	*this += right;
	return *this;
}

MyString MyString::substr(int po, int len)const {
	if (len + po  > getSize()) {
		len = getSize() - po;
	}
	MyString temp;
	temp.resize(len, ' ');
	for (int i = 0; i < len; i++) {
		temp.at(i) = at(po + i);
	}
	return temp;
}
MyString& MyString::insert(int po, const MyString&right) {
	MyString temp=this->substr( po, getSize() - po);
	erase(po, getSize() - po);
	*this += right;
	*this += temp;
	return *this;
}
MyString& MyString::insert(int po, const MyString&right, int po2, int ed) {
	if (ed > right.getSize()-1) {
		ed = right.getSize() -1;
	}
	MyString temp = this->substr(po, getSize() - po);
	erase(po, getSize() - po);
	MyString temp2 = right.substr(po2, ed - po2+1);
	*this += temp2;
	*this += temp;
	return *this;
}
MyString& MyString::erase(int po, int len) {
	if (len + po > getSize()) {
		len = getSize() - po;
	}
	MyString temp=this->substr(po+len,getSize()-po-len);
	MyString temp2 = *this;
	temp2.resize(getSize() - len,' ');
	for (int i = 0; i < po; i++) {
		temp2.at(i) = at(i);
	}
	for (int i = po; i < temp2.getSize(); i++) {
		temp2.at(i) = temp.at(i - po);
	}
	return *this=temp2;
}
int MyString::find(const MyString&right, int pos )const {
	bool ans = 0;
	int check = 0;
	int posing=0;
	for (int i = 0; i+pos < getSize(); i++) {
		int j = i;
		int k = 0;
		while (at(i + pos) == right.at(k)) {
			if (check == right.getSize()-1) {
				ans = 1;
				posing = i + pos - right.getSize() + 1;
				break;
			}
			check++;
			i++;
			k++;
		}
		i = j;
		check = 0;
	}
	if (ans == 1)
		return posing;
	else
		return msize;

}
int MyString::find_first_of(const MyString&right, int pos)const {
	int ans = msize;
	for (int i = pos; i < getSize(); i++) {
		for (int j = 0; j < right.getSize(); j++) {
			if (at(i) == right.at(j)) {
				ans = i;
				break;
			}
		}
		if (ans != msize)
			break;
	}
	return ans;
}
#endif
