#include"s1073501_MyArray.h"
template< typename T >
MyArray<T>::MyArray(int c) {
	this->size = 0;
	this->capacity = 10;
	this->data = new T[c]{ NULL };
}
template<typename T>
MyArray<T>::MyArray(int Size, T value) {
	this->size = Size;
	this->capacity = 10;
	while (this->size > this->capacity) {
		capacity *= 2;
	}
	this->data = new T[capacity]{ NULL };
	for (int i = 0; i < size; i++) {
		this->data[i] = value;
	}
}

template< typename T >
MyArray<T>::MyArray(const MyArray& a) {
	this->size = a.size;
	this->capacity = a.capacity;
	this->data = new T[capacity]{ NULL };
	for (int i = 0; i < a.size; i++) {
		this->data[i] = a.data[i];
	}
}
template< typename T >
MyArray<T>::~MyArray() {
	data = NULL;
	delete[] data;
	size = 0;
	capacity = 0;
}

template< typename T >
int MyArray<T>::getSize() const {
	return size;
}
template< typename T >
int MyArray<T>::getCapacity() const {
	return capacity;
}
template< typename T >
void MyArray<T>::resize(size_t n, T c) {//可貸一個參數或兩個沒帶c就預設為0
	clear();
	while (n > capacity)
		reserve(capacity * 2);
	if (n > size) {
		for (int i = size; i < n; i++) {//超過size的職初始化
			data[i] = c;
		}
	}
	size = n;

}
template< typename T >
void MyArray<T>::reserve(size_t n) {
	if (n > capacity) {
		T* tmp = new T[n]();
		for (int i = 0; i < size; i++) {
			tmp[i] = data[i];
		}
		capacity = n;
		delete[]data;
		data = tmp;
	}
}
template<typename T>
void MyArray<T>::shrink_to_fit() {
	capacity = size;
}
template<typename T>
void MyArray<T>::clear() {
	//cout << "data is clear !"<< endl;
	size = 0;

}
template<typename T>
bool MyArray<T>::isEmpty() {
	if (size != 0) {
		cout << "data is not empty!" << endl;
		return false;
	}
	else {
		cout << "data is empty!" <<endl;
		return true;
	}
		
}
template< typename T >
int& MyArray<T>::operator[](int x)//[]中括號用於將資料進行條件篩選的指標(indexing)
{
	if (x < 0 || x >= size) {
		cout << "error"<<endl;
	}
	return this->data[x];
}
template< typename T >
int MyArray<T>::operator[](int x) const {
	/*if (x < 0 || x >= size) {
		cout << "error" << endl;
	}*/
	return this->data[x];
}

template<typename T>
T& MyArray<T>::at(int index){
	if (index > size)
		throw out_of_range(" is out of range");
	return data[index];
}

template<typename T>
T MyArray<T>::at(int index) const{
	if (index > size) 
		throw out_of_range(" is out of range ! ");
	
	return data[index];
	
	
}


template<typename T>
const MyArray<T>& MyArray<T>::operator=(const MyArray&x) {
	this->size = x.size;
	this->capacity = x.capacity;
	data = NULL;
	delete[] data;
	data = new T[capacity];
	for (int i = 0; i < size; i++) {
		this->data[i] = x.data[i];
	}

	return *this;
}

template< typename T >
bool MyArray<T>::operator==(const MyArray& x)const {
	if (this->size != x.size) {
		return false;
	}
	else {
		for (int i = 0; i < this->size; i++) {
			if (this->data[i] != x.data[i]) {
				return false;
			}
			return true;
		}
	}
}
template< typename T >
bool MyArray<T>::operator!=(const MyArray& x) const {
	return !(*this == x);
}

template<typename T>
MyArray<T> MyArray<T>::operator+(const MyArray &obj) const {
	MyArray tmp;
	tmp.size = this->size + obj.size;
	cout << "tmp size:" << tmp.size << endl;;
	tmp.resize(tmp.size,0);
	for (int i = 0; i < this->size; i++) {
		tmp.data[i] = this->data[i];
	}
	for (int j = this->size; j < tmp.size; j++) {
		tmp.data[j] = obj.data[j - size];	//Tmp.data[obj.size］=obj.data[0]
	}
		return tmp;
}
template<typename T>
MyArray<T>& MyArray<T>::operator+=(const MyArray& obj){
	MyArray tmp;
	int s = this->size;
	tmp.size = s+ obj.size;
	tmp.resize(tmp.size, 0);
	cout << "tmp size:" << tmp.size << endl;
	for (int i = 0; i < this->size; i++) {
		tmp.data[i] = this->data[i];
	}
	for (int j = this->size; j < tmp.size; j++) {
		tmp.data[j] = obj.data[j - size];
	}
	//cout << "tmp:" << tmp;
	*this = tmp;
	return *this;

}
#ifndef Header
#define Header
#include<iostream>
#include<exception>
#include<stdexcept>
using namespace std;
template< typename T >
class MyArray {	//modify this class into a template class
	friend ostream& operator<<(ostream&out, const MyArray&obj) {
		for (int i = 0; i < obj.size; i++) {
			out << obj.data[i];
		}
		cout << endl;
		return out;
	};
	/*friend istream& operator>>(istream&, MyArray&);*/
public:
	MyArray(int Capacity = 10);
	MyArray(int Size, T value);
	MyArray(const MyArray&);
	~MyArray();
	//MyArray(int Size, T[]);
	const MyArray& operator=(const MyArray&);
	bool operator==(const MyArray&) const;
	bool operator!=(const MyArray&) const;
	MyArray<T> operator+(const MyArray&) const;	//new
	MyArray<T>& operator+=(const MyArray&);		//new
	int& operator[](int);
	int operator[](int) const;
	T& at(int);		//new
	T at(int) const;//new

	int getSize() const;
	int getCapacity() const;
	void resize(size_t size, T item);//n,c
	void reserve(size_t size);
	void shrink_to_fit();	//new
	void clear();			//new
	bool isEmpty();			//new
protected:
	int size;
	int capacity;
	T* data;
};
//template class  MyArray <char>;
//template class  MyArray <int>;
#endif // !MyArray


#ifndef PG2MyString_H
#define PG2MyString_H
#include <iostream>
#include<exception>
#include<stdexcept>
#include<cstdint>
#include<stdlib.h>
#include<cstring>
#include "s1073501_MyArray.h"
using namespace std;

class MyString : public MyArray<char>{
	friend ostream &operator<<(ostream& out, const MyString& str){
		for (int i = 0; i < str.size; i++) 
			out << str.data[i];
		cout << endl;
		return out;
	};
public:
	MyString() : MyArray() {
		this->capacity = 10;
		this->size = 0;
		this->data = new char[capacity]{};
	}
	
// Constructs a copy of "str". (copy constructor)
	MyString(const MyString& str) {
		size = str.getSize();
		capacity = str.getCapacity();
		data = new char[capacity];

		memcpy(data, str.data, str.size + 1);
		/*for (int i = 0; i < str.getSize(); i++) {
			this->data[i] = str.data[i];
		}*/

		/*int len = strlen(str.data);
		data = new char[len + 1];
		strcpy(this->data, str.data);*/
	}
	// (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).
	MyString(const MyString& str, size_t pos, size_t len = msize):MyArray() {
		if(len==msize)
		this->size =pos - len;
		else {
			this->size = len - pos;
		}
		this->capacity = 10;
		while (this->size > this->capacity) {
			capacity *= 2;
		}
		this->data = new char[capacity]{ NULL };
		//for (int i = pos ; i < len; i++) {
		//	//for(int j=0; j<len; j++)
		//}
		if (len == msize) {
			for (int i = 0;i < this->size;i++) {
				this->data[i] = str.data[i];
			}
		}
		else {
			for (int i = pos, j = 0; i < len; i++, j++) {
				this->data[j] = str.data[i];
			}
		}
	}
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	MyString(const char* a): MyArray(){
		int len = strlen(a);
		/*for (int i = 0; i < strlen(a); i++) {
			data[i] = a.data[i];
		}*/

		data = new char[capacity];
		memcpy(data, a, len + 1);
		size = len;
	}
	~MyString() {
		data = NULL;
		delete[] data;
		size = 0;
		capacity = 0;
	}
	static const size_t msize = -1;
	//Note: maximum size. You may use SIZE_MAX at <cstdint>, too.

	MyString& append(const MyString& str) {
		MyString tmp = str;
		int s = this->size;
		tmp.size = s + str.size;
		tmp.resize(tmp.size, 0);
		this->capacity = str.getCapacity();

		//cout << "tmp size:" << tmp.size << endl;;

		for (int i = 0; i < this->size; i++) {
			tmp.data[i] = this->data[i];
		}
		for (int j = this->size; j < tmp.size; j++) {
			tmp.data[j] = str.data[j - size];	//Tmp.data[obj.size］=obj.data[0]
		}
		*this = tmp;
		return *this;
	}
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos, size_t len = msize) const {
		MyString tmp;
		tmp.resize(len,NULL);
		for (int i = pos;i < len + pos;i++) {
			tmp.data[i-pos] = this->data[i];
		}
		
		//tmp.size = len + pos;
		//tmp.resize(tmp.size, 0);
		//for (int i = 0; i < this->size; i++) {
		//	tmp.data[i] = this->data[i];
		//}
		//for (int j = this->size; j < tmp.size; j++) {
		//	tmp.data[j] = this->data[j - size];	//Tmp.data[obj.size］=obj.data[0]
		//}
		return tmp;
	}
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.
	MyString& insert(size_t pos, const MyString& str) {
		size_t lengthDest = size;
		size_t lengthSource = str.size;
		MyString tmp(data);
		tmp.size = size + str.size;
		this->size = tmp.size;
		tmp.capacity = 10;
		while (this->size > this->capacity) {
			capacity *= 2;
		}
		tmp.capacity = capacity;
		data = new char[lengthSource + lengthDest + 1];
		for (int i = 0; i < pos; i++)
			data[i] = tmp.data[i];
		for (int i = pos, j = 0;i < str.size + pos; i++, j++)
			data[i] = str.data[j];
		for (int i = pos + str.size, j = 0;i < tmp.size;i++, j++) 
			data[i] = tmp.data[pos + j];
			return *this;
	}
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert(size_t pos, const MyString& str, size_t subpos, size_t sublen = msize) {
		MyString tmp ;
		tmp = str.substr(subpos, sublen);
		//cout << tmp << endl;
		this->insert(pos, tmp);
		return *this;
		//if (sublen == msize)
		//	tmp.size=this->size + (str.getSize()-subpos);
		//else {
		//	tmp.size = this->size + sublen;
		//}
		////this->capacity = 10;
		//while (tmp.size > tmp.capacity) {
		//	tmp.capacity *= 2;
		//}
		//tmp.data = new char[tmp.capacity]();
		////MyString tmp;
		////tmp.size = size + str.size;
		//////this->size = tmp.size;
		////tmp.capacity = 10;
		////while (tmp.size > tmp.capacity) {
		////	tmp.capacity *= 2;
		////}
		////tmp.capacity = capacity;
		//if (sublen == msize) {
		//	for (int i = 0;i < pos;i++) {
		//		tmp.data[i] = this->data[i];
		//	}
		//	for (int i = pos, j = subpos;i < (str.getSize() - subpos);i++, j++)tmp.data[i] = str.data[j];
		//	for (int i = pos + (str.getSize() - subpos),  j = pos;i < tmp.size;i++, j++)tmp.data[i] = this->data[j];
		//}
		//else {
		//	/*for (int i = 0;i < pos;i++)
		//		tmp.data[i] = this->data[i];//to be (6)
		//	for (int i = pos, j = subpos; i < pos + sublen; j++, i++) {
		//		if (j < subpos + sublen - 1)
		//			tmp.data[i] = str.data[j];//not
		//		
		//	}
		//	for (int i = pos + sublen, j = pos; i < size + sublen; j++, i++) {//這裡吃步道植ㄚㄚㄚ
		//		tmp.data[i] = this->data[j];
		//	}*/
		//	for (int i = 0;i < pos;i++)
		//		tmp.data[i] = this->data[i];
		//	for(int j=pos;j<pos+sublen;j++)
		//		tmp.data[j] = str.data[j];
		//	for(int i= pos + sublen;i<tmp.size;i++)
		//		tmp.data[i] = this->data[i];
		//}
		//*this = tmp;
		//return *this;
	}
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase(size_t pos, size_t len = msize) {
	if (pos >= size) {
		cout << "Index out of range." << endl;
		return *this;
	}
	if (pos == 0 && len == -1) {
		clear();
	}
	else if (pos + len > size) {
		*(data + pos) = '\0';
		size = pos + 1;
	}
	else {
		for (int i = 0; i < len; i++) {
			*(data + pos + i) = *(data + pos + len + i);
		}
		*(data + pos + len) = '\0';
		size -= len;
	}
	return *this;
}
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	/*size_t find(const MyString& str, size_t pos = 0) const {
		if (pos > str.size ){
			cout << "fail pos " << str.size << endl;
			return -1;
		}
		char ch = str.data[pos--];
		for (int i = pos;i < size;i++){
			if (ch == data[i])
				return i ;
		}
	}*/
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

/* size_t find_first_of(const MyString& str, size_t pos = 0) const {
	
}*/
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.


}; // end class MyStrin

#endif
