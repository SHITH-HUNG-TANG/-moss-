#include"s1061637_MyArray.h"
#include<cstdlib>
template <class T>
MyArray<T>::MyArray(size_t cap) :size(0)
{
	this->capacity = cap;	
	data = new T[this->capacity];
}
template <class T>
MyArray<T>::MyArray(const MyArray & right)
{
	this->capacity = right.capacity;
	this->size = right.size;
	data = new T[this->capacity];
	for (size_t i=0; i < size; i++)
		this->data[i] = right.data[i];

}
template <class T>
MyArray<T>::MyArray(int size, T value)
{
	this->capacity = size*2;
	this->size = size;
	data = new T[this->capacity];
	for (size_t i = 0; i < size; i++)
		this->data[i] = value;

}
template <class T>
MyArray<T>::~MyArray() { delete []data; }
template <class T>
const MyArray<T>& MyArray<T>::operator= (const MyArray & right)
{
	delete[]this->data;
	this->capacity = right.capacity;
	this->size = right.size;
	
	data = new T[right.capacity];
	for (size_t i = 0; i < right.size; i++)
	{
		this->data[i] = right.data[i];
	}
	return *this;
}
template <class T>
bool MyArray<T>::operator == (const MyArray & right)const
{
	if (this->size != right.size)
		return 0;
	else 
		for (size_t i = 0; i < this->size; i++)
		{
			if (this->data[i] != right.data[i])
				return 0;
		}
	return 1;
}

template <class T>
bool MyArray<T>::operator != (const MyArray & right)const
{
	return *this == right;
}

template <class T>
T& MyArray<T>::operator[](int input)
{
	return data[input];
}
template <class T>
const T  MyArray<T>::operator[](int input)const
{

	return this->data[input];
}
template <class T>
int MyArray<T>::getSize()const
{
	return size;
}
template <class T>
int MyArray<T>::getCapacity()const
{
	return   capacity;
}
template <class T>
void MyArray<T>::resize(size_t n, T c)
{
	while (n > capacity)
		 reserve(2* capacity);
	if (n > size)
		for (size_t i = size; i < n; i++)
			data[i] = c;
	size = n;
}
template <class T>
void MyArray<T>::reserve(size_t input) 
{
	if(capacity< input)
	{
		T *temp = new T[input];
		copy(data,data+size,temp);
		delete[]data;

		data = temp;
	    capacity = input;
	}
	
}
/*template <class T>
ostream &operator<<(ostream & os , const MyArray<T>& arr)
{
	int i = 0;
	while (i < arr.size)
		os << arr[i];
	return os;
}*/
/*ostream &operator<<(ostream & os, const MyArray<char>& arr)
{
	int i = arr.size;
	while (--i >= 0)
		os << arr[i];
	return os;
}*/
template <class T>
void MyArray<T>::shrink_to_fit()
{
	MyArray<T>temp(*this);
	this->data = new T[this->size];
	copy(temp.data, temp.data + this->size, this->data);
	this->capacity = this->size;
}
template <class T>
bool MyArray<T>::isEmpty()
{
	if (this->size == 0)
		return 1;
	return 0;
}
template <class T>
void MyArray<T>::clear()
{
	if(!isEmpty())
		size = 0;
}
template <class T>
T& MyArray<T>::at(int input)
{
	if (size < input)
	{
		cout << "outoflist";
		throw(std::out_of_range("outoflist"));
	}
	else
		return data[input-1];
}
	//new

template <class T>
const T&  MyArray<T>::at(int input)const
{
	if (size < input)
	{
		cout << "outoflist";
		exit(0);	
	}
	else
		return data[input - 1];
}
template <class T>
const MyArray<T>& MyArray<T>::operator+= (const MyArray<T> & str)
{

	this->reserve(this->size + str.size);
	copy( str.data , str.data+ str.size, this->data+ this->size);
	this->size = this->size + str.size;
	return *this;
}
template <class T>
MyArray<T>  MyArray<T>:: operator+ (const MyArray<T>& right)
{
	
		MyArray<T>temp;
		temp.reserve(this->size + right.size);
		copy(this->data, this->data + this->size,temp.data);
		copy(right.data , right.data + right.size , temp.data+size);
		temp.size = this->size + right.size;
		return  temp;
	
}


/*template <class T>
istream& operator>>(istream&, MyArray<T>&)
{
	
}*/

template class MyArray<char>;
template class MyArray<long long int>;




#pragma once
#include<iostream>
using namespace std;
template<class T>
#ifndef xxxxx
class MyArray {	//modify this class into a template class
	friend ostream& operator<<(ostream& os , const MyArray<T>& str)
	{
		{
			for (int i =0; i <str.size; i++)
				os << str.data[i];
			return os;
		}
	}
	//friend istream& operator>>(istream&, MyArray<T>&);
public:
	MyArray(size_t Capacity = 10);
	MyArray(int Size, T value);
	MyArray(const MyArray<T>&);
	~MyArray();

	const MyArray<T>& operator=(const MyArray<T>&);
	bool operator==(const MyArray<T>&) const;
	bool operator!=(const MyArray<T>&) const;
	MyArray<T> operator+(const MyArray<T>&);
	//MyArray<T> operator+(const MyArray<T>& right);
	const MyArray<T>& operator+=(const MyArray<T>&);//new
	
	T& operator[](int);
	const T operator[](int) const;//¤£À´
	T& at(int);		//new
	const T& at(int) const;	//new

	int getSize() const;
	int getCapacity() const;
	void resize(size_t size, T item);
	void reserve(size_t size);
	void shrink_to_fit();	//new
	void clear();			//new
	bool isEmpty();			//new

protected:
	int size;
	int capacity;
	T* data;
};
#endif // !MyArray
#include"s1061637_MyString.h"
#include<iostream>
#include <string>
using namespace std;
MyString::MyString() :MyArray(10) {}
MyString::MyString(const MyString &str)
{
	delete[]data;
	this->data = new char[str.capacity];
	capacity = str.capacity;
	for (size_t i = 0; i < str.size; i++)
		data[i] = str.data[i];
	size = str.size;
}
MyString::MyString(const MyString &str, size_t pos, size_t len)
{
	if (len-1+pos > str.size|| len==-1)
		len = str.size-pos+1;
	delete[]data;
	data = new char[str.capacity];
	capacity = str.capacity;
	size = len;
	for (size_t i = 0, start = pos-1; i <len; i++, start++)
	{
		data[i] = str.data[start];	
	}
	
}
MyString::MyString(const char *s)
{
	int inputsize = 0;
	for (size_t i = 0; s[i] != '\0'; i++)
		++inputsize;
	capacity = inputsize;
	size = inputsize;
	data = new char[inputsize];
	copy(s, s + inputsize, data);
}
MyString&  MyString::append(const MyString &str)
{
	
	MyArray::reserve(str.size+ MyArray::size);
	copy(str.data , str.data+ str.size   , data+size);

	size = str.size + MyArray::size;
	return *this;

}
MyString& MyString::insert(size_t pos, const MyString &str)
{
	MyArray::reserve(str.size + MyArray::size);
	int tempsize = size - pos;
	char* temp = new char[tempsize];
	copy(data + pos, data + size, temp);
	copy(str.data, str.data + str.size,data + pos);
	copy(temp, temp + tempsize, data + pos+ str.size);
	size = str.size + size;
	return *this;
}

MyString& MyString::insert(size_t pos, const MyString&str, size_t subpos, size_t sublen)
{//全部都是陣列大小
	
	if (subpos+ sublen > str.size+1|| sublen==-1)
		sublen = str.size-subpos+1;
	if (size < pos || subpos> str.size)
	{
		throw(std::out_of_range("索引值超出陣列") );
	}
	else
	{ 
		MyArray::reserve(sublen + MyArray::size);
		int tempsize = size - pos;
		char* temp = new char[tempsize];
		copy(data + pos, data + size, temp);//複製後面
		copy(str.data+subpos-1, str.data + subpos-1+sublen,data+pos);//複製右邊
		copy(temp, temp + tempsize, data + pos + sublen);
		size = sublen + size;
		return *this;
	}
}
MyString & MyString::erase(size_t pos, size_t len)//pos是實際位置
{
	if (len-1+ pos > size || len ==	 -1)
		len = size - pos+1;
	MyString right;
	right.MyArray::reserve(this->size -pos + 1 - len );
	copy(data+pos - 1 + len, data+this->size, right.data);
	right.size = this->size - pos + 1 - len;

	MyString left;
	left.MyArray::reserve(pos-1);
	copy(data , data +pos,left.data);
	left.size = pos - 1;
	this->size = 0;
	this->append(left).append(right);

	return *this;
}
	

MyString  MyString::substr(size_t pos, size_t len) const
{
	return MyString (*this,pos, len);
}

//template <class T>
 /*istream &operator>>(istream & in, MyString& str)
{
	 string temp;
	 in >> temp;
	 str.reserve(temp.size());
	 for (size_t i = 0; i < temp.size(); i++)
	 {
		 str.data[i] = temp[i];
	 }
	 size = temp.size;

}*/
	

 size_t MyString::find(const MyString &str, size_t pos = 0) const   //aboxoxcox
 {
	 for (size_t i = pos - 1; i < this->size; i++)
	 {
		 for (size_t j = 0; j < str.size; j++)
		 {
			 if (this->data[i + j] != str.data[j])
				 break;
			 else
			 {
				 if (j == str.size - 1)
					 return i + 1;
			 }
		 }
	 }
	 return  MyString::msize;
 }
 size_t MyString::find_first_of(const MyString &str, size_t pos = 0) const
 {
	 
	 for (size_t i = pos - 1; i < this->size; i++)
	 {
		 for (size_t j = 0; j < str.size; j++)
		 {

			 if (str[j] == this->data[i])
			 {
				 
				 return  i + 1;
			 }
		 }
	 }
	 return  MyString::msize;
 }#ifndef PG2MyString_H
#define PG2MyString_H
#include <iostream>
#include"s1061637_MyArray.h"
using namespace std;

class MyString :public MyArray<char>
{
	friend ostream& operator<<(ostream& os, const MyString& str)
	{
		
			{
				for (int i = 0; i < str.size; i++)
					os << str.data[i];
				return os;
			}
		
	}
public:
	MyString(); 
	// Constructs an empty string, with a length of zero characters. 
	// *default capacity = 10

	MyString( const MyString &str ); 
	// Constructs a copy of "str". (copy constructor)

	MyString( const MyString &str, size_t pos, size_t len = msize ); // (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).

	MyString( const char *s ); 
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	//~MyString(); 
	// Destroys the string object.

	static const size_t msize = -1;
	
	//Note: maximum size. You may use SIZE_MAX at <cstdint>, too.

	MyString& append( const MyString &str ); 
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos, size_t len = msize) const;
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.

	MyString& insert( size_t pos, const MyString &str);
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert( size_t pos, const MyString &str, size_t subpos, size_t sublen = msize );
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase( size_t pos, size_t len = msize ); 
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	size_t find( const MyString &str, size_t pos ) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

	size_t find_first_of( const MyString &str, size_t pos) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.

	//You may add several helper functions or operators here
	//...
}; // end class MyString

#endif#include"s1061637_MyArray.h"
#include<cstdlib>
template <class T>
MyArray<T>::MyArray(size_t cap) :size(0)
{
	this->capacity = cap;	
	data = new T[this->capacity];
}
template <class T>
MyArray<T>::MyArray(const MyArray & right)
{
	this->capacity = right.capacity;
	this->size = right.size;
	data = new T[this->capacity];
	for (size_t i=0; i < size; i++)
		this->data[i] = right.data[i];

}
template <class T>
MyArray<T>::MyArray(int size, T value)
{
	this->capacity = size*2;
	this->size = size;
	data = new T[this->capacity];
	for (size_t i = 0; i < size; i++)
		this->data[i] = value;

}
template <class T>
MyArray<T>::~MyArray() { delete []data; }
template <class T>
const MyArray<T>& MyArray<T>::operator= (const MyArray & right)
{
	delete[]this->data;
	this->capacity = right.capacity;
	this->size = right.size;
	
	data = new T[right.capacity];
	for (size_t i = 0; i < right.size; i++)
	{
		this->data[i] = right.data[i];
	}
	return *this;
}
template <class T>
bool MyArray<T>::operator == (const MyArray & right)const
{
	if (this->size != right.size)
		return 0;
	else 
		for (size_t i = 0; i < this->size; i++)
		{
			if (this->data[i] != right.data[i])
				return 0;
		}
	return 1;
}

template <class T>
bool MyArray<T>::operator != (const MyArray & right)const
{
	return *this == right;
}

template <class T>
T& MyArray<T>::operator[](int input)
{
	return data[input];
}
template <class T>
const T  MyArray<T>::operator[](int input)const
{

	return this->data[input];
}
template <class T>
int MyArray<T>::getSize()const
{
	return size;
}
template <class T>
int MyArray<T>::getCapacity()const
{
	return   capacity;
}
template <class T>
void MyArray<T>::resize(size_t n, T c)
{
	while (n > capacity)
		 reserve(2* capacity);
	if (n > size)
		for (size_t i = size; i < n; i++)
			data[i] = c;
	size = n;
}
template <class T>
void MyArray<T>::reserve(size_t input) 
{
	if(capacity< input)
	{
		T *temp = new T[input];
		copy(data,data+size,temp);
		delete[]data;

		data = temp;
	    capacity = input;
	}
	
}
/*template <class T>
ostream &operator<<(ostream & os , const MyArray<T>& arr)
{
	int i = 0;
	while (i < arr.size)
		os << arr[i];
	return os;
}*/
/*ostream &operator<<(ostream & os, const MyArray<char>& arr)
{
	int i = arr.size;
	while (--i >= 0)
		os << arr[i];
	return os;
}*/
template <class T>
void MyArray<T>::shrink_to_fit()
{
	MyArray<T>temp(*this);
	this->data = new T[this->size];
	copy(temp.data, temp.data + this->size, this->data);
	this->capacity = this->size;
}
template <class T>
bool MyArray<T>::isEmpty()
{
	if (this->size == 0)
		return 1;
	return 0;
}
template <class T>
void MyArray<T>::clear()
{
	if(!isEmpty())
		size = 0;
}
template <class T>
T& MyArray<T>::at(int input)
{
	if (size < input)
	{
		cout << "outoflist";
		throw(std::out_of_range("outoflist"));
	}
	else
		return data[input-1];
}
	//new

template <class T>
const T&  MyArray<T>::at(int input)const
{
	if (size < input)
	{
		cout << "outoflist";
		exit(0);	
	}
	else
		return data[input - 1];
}
template <class T>
const MyArray<T>& MyArray<T>::operator+= (const MyArray<T> & str)
{

	this->reserve(this->size + str.size);
	copy( str.data , str.data+ str.size, this->data+ this->size);
	this->size = this->size + str.size;
	return *this;
}
template <class T>
MyArray<T>  MyArray<T>:: operator+ (const MyArray<T>& right)
{
	
		MyArray<T>temp;
		temp.reserve(this->size + right.size);
		copy(this->data, this->data + this->size,temp.data);
		copy(right.data , right.data + right.size , temp.data+size);
		temp.size = this->size + right.size;
		return  temp;
	
}


/*template <class T>
istream& operator>>(istream&, MyArray<T>&)
{
	
}*/

template class MyArray<char>;
template class MyArray<long long int>;




#pragma once
#include<iostream>
using namespace std;
template<class T>
#ifndef xxxxx
class MyArray {	//modify this class into a template class
	friend ostream& operator<<(ostream& os , const MyArray<T>& str)
	{
		{
			for (int i =0; i <str.size; i++)
				os << str.data[i];
			return os;
		}
	}
	//friend istream& operator>>(istream&, MyArray<T>&);
public:
	MyArray(size_t Capacity = 10);
	MyArray(int Size, T value);
	MyArray(const MyArray<T>&);
	~MyArray();

	const MyArray<T>& operator=(const MyArray<T>&);
	bool operator==(const MyArray<T>&) const;
	bool operator!=(const MyArray<T>&) const;
	MyArray<T> operator+(const MyArray<T>&);
	//MyArray<T> operator+(const MyArray<T>& right);
	const MyArray<T>& operator+=(const MyArray<T>&);//new
	
	T& operator[](int);
	const T operator[](int) const;//¤£À´
	T& at(int);		//new
	const T& at(int) const;	//new

	int getSize() const;
	int getCapacity() const;
	void resize(size_t size, T item);
	void reserve(size_t size);
	void shrink_to_fit();	//new
	void clear();			//new
	bool isEmpty();			//new

protected:
	int size;
	int capacity;
	T* data;
};
#endif // !MyArray
#include"s1061637_MyString.h"
#include<iostream>
#include <string>
using namespace std;
MyString::MyString() :MyArray(10) {}
MyString::MyString(const MyString &str)
{
	delete[]data;
	this->data = new char[str.capacity];
	capacity = str.capacity;
	for (size_t i = 0; i < str.size; i++)
		data[i] = str.data[i];
	size = str.size;
}
MyString::MyString(const MyString &str, size_t pos, size_t len)
{
	if (len-1+pos > str.size|| len==-1)
		len = str.size-pos+1;
	delete[]data;
	data = new char[str.capacity];
	capacity = str.capacity;
	size = len;
	for (size_t i = 0, start = pos-1; i <len; i++, start++)
	{
		data[i] = str.data[start];	
	}
	
}
MyString::MyString(const char *s)
{
	int inputsize = 0;
	for (size_t i = 0; s[i] != '\0'; i++)
		++inputsize;
	capacity = inputsize;
	size = inputsize;
	data = new char[inputsize];
	copy(s, s + inputsize, data);
}
MyString&  MyString::append(const MyString &str)
{
	
	MyArray::reserve(str.size+ MyArray::size);
	copy(str.data , str.data+ str.size   , data+size);

	size = str.size + MyArray::size;
	return *this;

}
MyString& MyString::insert(size_t pos, const MyString &str)
{
	MyArray::reserve(str.size + MyArray::size);
	int tempsize = size - pos;
	char* temp = new char[tempsize];
	copy(data + pos, data + size, temp);
	copy(str.data, str.data + str.size,data + pos);
	copy(temp, temp + tempsize, data + pos+ str.size);
	size = str.size + size;
	return *this;
}

MyString& MyString::insert(size_t pos, const MyString&str, size_t subpos, size_t sublen)
{//全部都是陣列大小
	
	if (subpos+ sublen > str.size+1|| sublen==-1)
		sublen = str.size-subpos+1;
	if (size < pos || subpos> str.size)
	{
		throw(std::out_of_range("索引值超出陣列") );
	}
	else
	{ 
		MyArray::reserve(sublen + MyArray::size);
		int tempsize = size - pos;
		char* temp = new char[tempsize];
		copy(data + pos, data + size, temp);//複製後面
		copy(str.data+subpos-1, str.data + subpos-1+sublen,data+pos);//複製右邊
		copy(temp, temp + tempsize, data + pos + sublen);
		size = sublen + size;
		return *this;
	}
}
MyString & MyString::erase(size_t pos, size_t len)//pos是實際位置
{
	if (len-1+ pos > size || len ==	 -1)
		len = size - pos+1;
	MyString right;
	right.MyArray::reserve(this->size -pos + 1 - len );
	copy(data+pos - 1 + len, data+this->size, right.data);
	right.size = this->size - pos + 1 - len;

	MyString left;
	left.MyArray::reserve(pos-1);
	copy(data , data +pos,left.data);
	left.size = pos - 1;
	this->size = 0;
	this->append(left).append(right);

	return *this;
}
	

MyString  MyString::substr(size_t pos, size_t len) const
{
	return MyString (*this,pos, len);
}

//template <class T>
 /*istream &operator>>(istream & in, MyString& str)
{
	 string temp;
	 in >> temp;
	 str.reserve(temp.size());
	 for (size_t i = 0; i < temp.size(); i++)
	 {
		 str.data[i] = temp[i];
	 }
	 size = temp.size;

}*/
	

 size_t MyString::find(const MyString &str, size_t pos = 0) const   //aboxoxcox
 {
	 for (size_t i = pos - 1; i < this->size; i++)
	 {
		 for (size_t j = 0; j < str.size; j++)
		 {
			 if (this->data[i + j] != str.data[j])
				 break;
			 else
			 {
				 if (j == str.size - 1)
					 return i + 1;
			 }
		 }
	 }
	 return  MyString::msize;
 }
 size_t MyString::find_first_of(const MyString &str, size_t pos = 0) const
 {
	 
	 for (size_t i = pos - 1; i < this->size; i++)
	 {
		 for (size_t j = 0; j < str.size; j++)
		 {

			 if (str[j] == this->data[i])
			 {
				 
				 return  i + 1;
			 }
		 }
	 }
	 return  MyString::msize;
 }#ifndef PG2MyString_H
#define PG2MyString_H
#include <iostream>
#include"s1061637_MyArray.h"
using namespace std;

class MyString :public MyArray<char>
{
	friend ostream& operator<<(ostream& os, const MyString& str)
	{
		
			{
				for (int i = 0; i < str.size; i++)
					os << str.data[i];
				return os;
			}
		
	}
public:
	MyString(); 
	// Constructs an empty string, with a length of zero characters. 
	// *default capacity = 10

	MyString( const MyString &str ); 
	// Constructs a copy of "str". (copy constructor)

	MyString( const MyString &str, size_t pos, size_t len = msize ); // (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).

	MyString( const char *s ); 
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	//~MyString(); 
	// Destroys the string object.

	static const size_t msize = -1;
	
	//Note: maximum size. You may use SIZE_MAX at <cstdint>, too.

	MyString& append( const MyString &str ); 
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos, size_t len = msize) const;
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.

	MyString& insert( size_t pos, const MyString &str);
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert( size_t pos, const MyString &str, size_t subpos, size_t sublen = msize );
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase( size_t pos, size_t len = msize ); 
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	size_t find( const MyString &str, size_t pos ) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

	size_t find_first_of( const MyString &str, size_t pos) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.

	//You may add several helper functions or operators here
	//...
}; // end class MyString

#endif#include"s1061637_MyArray.h"
#include<cstdlib>
template <class T>
MyArray<T>::MyArray(size_t cap) :size(0)
{
	this->capacity = cap;	
	data = new T[this->capacity];
}
template <class T>
MyArray<T>::MyArray(const MyArray & right)
{
	this->capacity = right.capacity;
	this->size = right.size;
	data = new T[this->capacity];
	for (size_t i=0; i < size; i++)
		this->data[i] = right.data[i];

}
template <class T>
MyArray<T>::MyArray(int size, T value)
{
	this->capacity = size*2;
	this->size = size;
	data = new T[this->capacity];
	for (size_t i = 0; i < size; i++)
		this->data[i] = value;

}
template <class T>
MyArray<T>::~MyArray() { delete []data; }
template <class T>
const MyArray<T>& MyArray<T>::operator= (const MyArray & right)
{
	delete[]this->data;
	this->capacity = right.capacity;
	this->size = right.size;
	
	data = new T[right.capacity];
	for (size_t i = 0; i < right.size; i++)
	{
		this->data[i] = right.data[i];
	}
	return *this;
}
template <class T>
bool MyArray<T>::operator == (const MyArray & right)const
{
	if (this->size != right.size)
		return 0;
	else 
		for (size_t i = 0; i < this->size; i++)
		{
			if (this->data[i] != right.data[i])
				return 0;
		}
	return 1;
}

template <class T>
bool MyArray<T>::operator != (const MyArray & right)const
{
	return *this == right;
}

template <class T>
T& MyArray<T>::operator[](int input)
{
	return data[input];
}
template <class T>
const T  MyArray<T>::operator[](int input)const
{

	return this->data[input];
}
template <class T>
int MyArray<T>::getSize()const
{
	return size;
}
template <class T>
int MyArray<T>::getCapacity()const
{
	return   capacity;
}
template <class T>
void MyArray<T>::resize(size_t n, T c)
{
	while (n > capacity)
		 reserve(2* capacity);
	if (n > size)
		for (size_t i = size; i < n; i++)
			data[i] = c;
	size = n;
}
template <class T>
void MyArray<T>::reserve(size_t input) 
{
	if(capacity< input)
	{
		T *temp = new T[input];
		copy(data,data+size,temp);
		delete[]data;

		data = temp;
	    capacity = input;
	}
	
}
/*template <class T>
ostream &operator<<(ostream & os , const MyArray<T>& arr)
{
	int i = 0;
	while (i < arr.size)
		os << arr[i];
	return os;
}*/
/*ostream &operator<<(ostream & os, const MyArray<char>& arr)
{
	int i = arr.size;
	while (--i >= 0)
		os << arr[i];
	return os;
}*/
template <class T>
void MyArray<T>::shrink_to_fit()
{
	MyArray<T>temp(*this);
	this->data = new T[this->size];
	copy(temp.data, temp.data + this->size, this->data);
	this->capacity = this->size;
}
template <class T>
bool MyArray<T>::isEmpty()
{
	if (this->size == 0)
		return 1;
	return 0;
}
template <class T>
void MyArray<T>::clear()
{
	if(!isEmpty())
		size = 0;
}
template <class T>
T& MyArray<T>::at(int input)
{
	if (size < input)
	{
		cout << "outoflist";
		throw(std::out_of_range("outoflist"));
	}
	else
		return data[input-1];
}
	//new

template <class T>
const T&  MyArray<T>::at(int input)const
{
	if (size < input)
	{
		cout << "outoflist";
		exit(0);	
	}
	else
		return data[input - 1];
}
template <class T>
const MyArray<T>& MyArray<T>::operator+= (const MyArray<T> & str)
{

	this->reserve(this->size + str.size);
	copy( str.data , str.data+ str.size, this->data+ this->size);
	this->size = this->size + str.size;
	return *this;
}
template <class T>
MyArray<T>  MyArray<T>:: operator+ (const MyArray<T>& right)
{
	
		MyArray<T>temp;
		temp.reserve(this->size + right.size);
		copy(this->data, this->data + this->size,temp.data);
		copy(right.data , right.data + right.size , temp.data+size);
		temp.size = this->size + right.size;
		return  temp;
	
}


/*template <class T>
istream& operator>>(istream&, MyArray<T>&)
{
	
}*/

template class MyArray<char>;
template class MyArray<long long int>;




#pragma once
#include<iostream>
using namespace std;
template<class T>
#ifndef xxxxx
class MyArray {	//modify this class into a template class
	friend ostream& operator<<(ostream& os , const MyArray<T>& str)
	{
		{
			for (int i =0; i <str.size; i++)
				os << str.data[i];
			return os;
		}
	}
	//friend istream& operator>>(istream&, MyArray<T>&);
public:
	MyArray(size_t Capacity = 10);
	MyArray(int Size, T value);
	MyArray(const MyArray<T>&);
	~MyArray();

	const MyArray<T>& operator=(const MyArray<T>&);
	bool operator==(const MyArray<T>&) const;
	bool operator!=(const MyArray<T>&) const;
	MyArray<T> operator+(const MyArray<T>&);
	//MyArray<T> operator+(const MyArray<T>& right);
	const MyArray<T>& operator+=(const MyArray<T>&);//new
	
	T& operator[](int);
	const T operator[](int) const;//¤£À´
	T& at(int);		//new
	const T& at(int) const;	//new

	int getSize() const;
	int getCapacity() const;
	void resize(size_t size, T item);
	void reserve(size_t size);
	void shrink_to_fit();	//new
	void clear();			//new
	bool isEmpty();			//new

protected:
	int size;
	int capacity;
	T* data;
};
#endif // !MyArray
#include"s1061637_MyString.h"
#include<iostream>
#include <string>
using namespace std;
MyString::MyString() :MyArray(10) {}
MyString::MyString(const MyString &str)
{
	delete[]data;
	this->data = new char[str.capacity];
	capacity = str.capacity;
	for (size_t i = 0; i < str.size; i++)
		data[i] = str.data[i];
	size = str.size;
}
MyString::MyString(const MyString &str, size_t pos, size_t len)
{
	if (len-1+pos > str.size|| len==-1)
		len = str.size-pos+1;
	delete[]data;
	data = new char[str.capacity];
	capacity = str.capacity;
	size = len;
	for (size_t i = 0, start = pos-1; i <len; i++, start++)
	{
		data[i] = str.data[start];	
	}
	
}
MyString::MyString(const char *s)
{
	int inputsize = 0;
	for (size_t i = 0; s[i] != '\0'; i++)
		++inputsize;
	capacity = inputsize;
	size = inputsize;
	data = new char[inputsize];
	copy(s, s + inputsize, data);
}
MyString&  MyString::append(const MyString &str)
{
	
	MyArray::reserve(str.size+ MyArray::size);
	copy(str.data , str.data+ str.size   , data+size);

	size = str.size + MyArray::size;
	return *this;

}
MyString& MyString::insert(size_t pos, const MyString &str)
{
	MyArray::reserve(str.size + MyArray::size);
	int tempsize = size - pos;
	char* temp = new char[tempsize];
	copy(data + pos, data + size, temp);
	copy(str.data, str.data + str.size,data + pos);
	copy(temp, temp + tempsize, data + pos+ str.size);
	size = str.size + size;
	return *this;
}

MyString& MyString::insert(size_t pos, const MyString&str, size_t subpos, size_t sublen)
{//全部都是陣列大小
	
	if (subpos+ sublen > str.size+1|| sublen==-1)
		sublen = str.size-subpos+1;
	if (size < pos || subpos> str.size)
	{
		throw(std::out_of_range("索引值超出陣列") );
	}
	else
	{ 
		MyArray::reserve(sublen + MyArray::size);
		int tempsize = size - pos;
		char* temp = new char[tempsize];
		copy(data + pos, data + size, temp);//複製後面
		copy(str.data+subpos-1, str.data + subpos-1+sublen,data+pos);//複製右邊
		copy(temp, temp + tempsize, data + pos + sublen);
		size = sublen + size;
		return *this;
	}
}
MyString & MyString::erase(size_t pos, size_t len)//pos是實際位置
{
	if (len-1+ pos > size || len ==	 -1)
		len = size - pos+1;
	MyString right;
	right.MyArray::reserve(this->size -pos + 1 - len );
	copy(data+pos - 1 + len, data+this->size, right.data);
	right.size = this->size - pos + 1 - len;

	MyString left;
	left.MyArray::reserve(pos-1);
	copy(data , data +pos,left.data);
	left.size = pos - 1;
	this->size = 0;
	this->append(left).append(right);

	return *this;
}
	

MyString  MyString::substr(size_t pos, size_t len) const
{
	return MyString (*this,pos, len);
}

//template <class T>
 /*istream &operator>>(istream & in, MyString& str)
{
	 string temp;
	 in >> temp;
	 str.reserve(temp.size());
	 for (size_t i = 0; i < temp.size(); i++)
	 {
		 str.data[i] = temp[i];
	 }
	 size = temp.size;

}*/
	

 size_t MyString::find(const MyString &str, size_t pos = 0) const   //aboxoxcox
 {
	 for (size_t i = pos - 1; i < this->size; i++)
	 {
		 for (size_t j = 0; j < str.size; j++)
		 {
			 if (this->data[i + j] != str.data[j])
				 break;
			 else
			 {
				 if (j == str.size - 1)
					 return i + 1;
			 }
		 }
	 }
	 return  MyString::msize;
 }
 size_t MyString::find_first_of(const MyString &str, size_t pos = 0) const
 {
	 
	 for (size_t i = pos - 1; i < this->size; i++)
	 {
		 for (size_t j = 0; j < str.size; j++)
		 {

			 if (str[j] == this->data[i])
			 {
				 
				 return  i + 1;
			 }
		 }
	 }
	 return  MyString::msize;
 }#ifndef PG2MyString_H
#define PG2MyString_H
#include <iostream>
#include"s1061637_MyArray.h"
using namespace std;

class MyString :public MyArray<char>
{
	friend ostream& operator<<(ostream& os, const MyString& str)
	{
		
			{
				for (int i = 0; i < str.size; i++)
					os << str.data[i];
				return os;
			}
		
	}
public:
	MyString(); 
	// Constructs an empty string, with a length of zero characters. 
	// *default capacity = 10

	MyString( const MyString &str ); 
	// Constructs a copy of "str". (copy constructor)

	MyString( const MyString &str, size_t pos, size_t len = msize ); // (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).

	MyString( const char *s ); 
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	//~MyString(); 
	// Destroys the string object.

	static const size_t msize = -1;
	
	//Note: maximum size. You may use SIZE_MAX at <cstdint>, too.

	MyString& append( const MyString &str ); 
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos, size_t len = msize) const;
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.

	MyString& insert( size_t pos, const MyString &str);
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert( size_t pos, const MyString &str, size_t subpos, size_t sublen = msize );
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase( size_t pos, size_t len = msize ); 
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	size_t find( const MyString &str, size_t pos ) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

	size_t find_first_of( const MyString &str, size_t pos) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.

	//You may add several helper functions or operators here
	//...
}; // end class MyString

#endif