#include "s1081504_MyArray.h"


template<typename T>
MyArray< T >::MyArray(int newCapactiy)//default constructor
{
	size = 0;
	data = new T[newCapactiy]();
	capacity = newCapactiy;
}
template<typename T>
MyArray< T >::MyArray(int newSize, T value)//initial constructor
{
	size = newSize;
	capacity = 10;
	if (newSize > capacity)
		while (newSize > capacity)
			capacity *= 2;
	else
		capacity = 10;

	data = new T[newSize]();
	for (int i(0); i < newSize; i++)
	{
		data[i] = value;
	}
}
template<typename T>
MyArray< T >::MyArray(T* arrayData, int newSize)//bonus constructor
{
	size = newSize;
	capacity = 10;
	if (newSize > capacity)
		while (newSize > capacity)
			capacity *= 2;
	else
		capacity = 10;

	data = new T[newSize]();
	for (int i(0); i < newSize; i++)
	{
		data[i] = arrayData[i];
	}
}
template<typename T>
MyArray< T >::~MyArray()//destructor
{
	delete[] data;
}
template<typename T>
MyArray< T >::MyArray(const MyArray& right)//copy constructor
{
	*this = right;
}
template<typename T>
MyArray< T >& MyArray< T >::operator=(const MyArray& right)
{
	if (this != &right)
	{
		data = new T[right.size + 1]();
		size = right.size;
		capacity = right.capacity;
		for (int i(0); i < right.size; i++)
		{
			data[i] = right.data[i];
		}
	}
	return *this;
}
template<typename T>
bool MyArray< T >::operator==(const MyArray& right)
{
	if (size == right.size)
		for (int i(size - 1); i >= 0 && data[i] == right.data[i]; i--)
			if (i == 0)
				return true;
	return false;
}
template<typename T>
bool MyArray< T >::operator!=(const MyArray& right)
{
	return !(*this == right);
}
template<typename T>
T MyArray< T >::operator[](int number) const
{
	return data[number];
}
template<typename T>
T& MyArray< T >::operator[](int number)
{
	return data[number];
}
template<typename T>
ostream& operator<<(ostream& out, const MyArray< T >& temp)
{
	for (int i(0); i < temp.getSize(); i++)
	{
		if (i < temp.getSize() - 1)
		{
			out << (T)temp[i] << " ";
		}
		else
			out << (T)temp[i] << " ";
	}
	return out;
}
template<typename T>
MyArray< T > MyArray< T >::operator+(const MyArray& right)
{
	MyArray temp(*this);
	temp.resize(temp.size + right.size);

	if (temp.size > temp.capacity)
	{
		while (temp.size > temp.capacity)
			reserve(temp.capacity * 2);
	}

	for (int i(size), j(0); i < right.size, j < right.size; i++, j++)
	{
		temp[i] = right[j];
	}
	return temp;
}
template<typename T>
MyArray< T >& MyArray< T >::operator+=(const MyArray& right)
{
	int tempSize(size);
	MyArray temp(*this);
	resize(size + right.size);

	if (temp.size > temp.capacity)
	{
		while (temp.size > temp.capacity)
			reserve(temp.capacity * 2);
	}

	for (int i(tempSize), j(0); i < right.size, j < right.size; i++, j++)
	{
		data[i] = right[j];
	}
	return *this;
}
template<typename T>
T& MyArray< T >::at(int index)
{
	if (index != 0 && (index - 1) <= size)
		return data[index];
	else if (index == 0)
		return data[index];
	else if (index != 0 && (index - 1) > size)
		throw out_of_range("");
}
template<typename T>
T MyArray< T >::at(int index) const
{
	if (index != 0 && (index - 1) <= size)
		return data[index];
	else if (index == 0)
		return data[index];
	else if (index != 0 && (index - 1) > size)
		throw out_of_range("");
}


template<typename T>
int MyArray< T >::getSize() const
{
	return size;
}
template<typename T>
int MyArray< T >::getCapacity() const
{
	return capacity;
}
template<typename T>
int* MyArray< T >::getData() const
{
	return data;
}
template<typename T>
void MyArray< T >::setData(int* newData)
{
	delete[] data;
	data = newData;
}
template<typename T>
void MyArray< T >::resize(size_t n, T item)
{
	while (n > capacity)
		reserve(capacity * 2);

	if (n > size)
	{
		for (int i(size); i < n; i++)
			data[i] = item;
	}
	size = n;
}
template<typename T>
void MyArray< T >::reserve(size_t n)
{
	if (n > capacity)
	{
		T* temp = new T[n]();
		for (int i = 0; i < size; i++)
			temp[i] = data[i];
		capacity = n;
		delete[] data;
		data = temp;
	}
}
template<typename T>
void MyArray< T >::shrink_to_fit()
{
	if (size < capacity)
	{
		capacity = size;
	}
}
template<typename T>
void MyArray< T >::clear()
{
	delete[] data;
	data = new T[1]();
	size = 0;
}
template<typename T>
bool MyArray< T >::isEmpty()
{
	if (size == 0)
		return true;
	return false;
}#ifndef S1081504_MYARRAY_H
#define S1081504_MYARRAY_H

#include <iostream>
#include <string>
#include <stdexcept>

using namespace std;

template<typename T>
class MyArray
{
	template<typename T>
	friend ostream& operator<<(ostream&, const MyArray&);
public:

	MyArray(int capacity = 10);
	MyArray(int size, T value);
	MyArray(T* arrayData, int size);
	~MyArray();
	MyArray(const MyArray&);

	MyArray& operator=(const MyArray&);
	bool operator==(const MyArray&);
	bool operator!=(const MyArray&);
	MyArray operator+(const MyArray&);
	MyArray& operator+=(const MyArray&);
	T operator[](int) const;
	T& operator[] (int);
	T& at(int);
	T at(int) const;

	int getSize() const;
	int getCapacity() const;
	int* getData() const;
	void setData(int* newPtr);
	void resize(size_t n, T item = '\0');
	void reserve(size_t n = 0);
	void shrink_to_fit();
	void clear();
	bool isEmpty();

private:
	int size = 0;
	int capacity;
	T* data;
};

#endif#include "s1081504_MyString.h"

MyString::MyString() : MyArray ()
{

}

MyString::MyString(const MyString& str) : MyArray(str)
{

}

MyString::MyString(const MyString& str, size_t pos, size_t len)
{
	if (len != msize && str.getSize() - 1 >= pos)
	{
		resize(len);
		if (len > getCapacity())
		{
			while (getCapacity() < len)
				reserve(getCapacity() * 2);
		}
		for (int i = 0, j = pos; i < len; i++, j++)
		{
			this->operator[](i) = str[j];
		}
	}
	else
	{
		resize(str.getSize() - pos);
		if (getSize() > getCapacity())
		{
			while (getCapacity() < getSize())
				reserve(getCapacity() * 2);
		}
		for (int i = 0, j = pos; i < getSize(); i++, j++)
		{
			this->operator[](i) = str[j];
		}
	}
}

MyString::MyString(const char* s)
{
	int newSize(0), counter(0);
	while (s[counter] != '\0')
	{
		newSize++;
		counter++;
	}
	resize(newSize);
	if (newSize > getCapacity())
	{
		while (getCapacity() < newSize)
			reserve(getCapacity() * 2);
	}
	for (int i(0); i < newSize; i++)
	{
		this->operator[](i) = s[i];
	}
}

MyString::~MyString()
{

}

ostream& operator<<(ostream& out, const MyString& temp)
{
	for (int i(0); i < temp.getSize(); i++)
	{
		out << temp[i];
	}
	return out;
}

istream& operator>>(istream& in, MyString& temp)
{
	string s("");

	getline(in, s);

	temp.resize(s.size(), '\0');

	while (temp.getSize() > temp.getCapacity())
	{
		temp.reserve(temp.getCapacity() * 2);
	}

	for (int i = 0; i < temp.getSize(); i++)
	{
		temp[i] = s[i];
	}

	return in;
}



MyString& MyString::append(const MyString& str)
{
	*this += str;
	return *this;
}

MyString MyString::substr(size_t pos, size_t len) const
{
	return MyString(*this, pos, len);
}

MyString& MyString::insert(size_t pos, const MyString& str)
{
	resize(getSize() + str.getSize());
	if (getSize() > getCapacity())
	{
		while (getCapacity() < getSize())
			reserve(getCapacity() * 2);
	}
	MyString temp(*this);
	for (int i = pos, j = pos + str.getSize(); i < pos + temp.getSize(); i++, j++)
	{
		this->operator[](j) = temp[i];
	}

	for (int i = pos, j = 0; j < str.getSize(); i++, j++)
	{
		this->operator[](i) = str[j];
	}

	return *this;
}

MyString& MyString::insert(size_t pos, const MyString& str, size_t subpos, size_t sublen)
{
	MyString temp(str, subpos, sublen);
	resize(getSize() + temp.getSize());
	if (getSize() > getCapacity())
	{
		while (getCapacity() < getSize())
			reserve(getCapacity() * 2);
	}
	MyString temp2(*this);
	for (int i = pos, j = pos + temp.getSize(); i < pos + temp2.getSize(); i++, j++)
	{
		this->operator[](j) = temp2[i];
	}

	for (int i = pos, j = 0; j < temp.getSize(); i++, j++)
	{
		this->operator[](i) = temp[j];
	}

	return *this;
}

MyString& MyString::erase(size_t pos, size_t len)
{
	if (len != msize && getSize() - 1 >= pos)
	{
		int tempSize(getSize());
		resize(getSize() - len);
		for (int i = pos; i < len; i++)
		{
			this->operator[](i) = '\0';
		}

		for (int i = pos + len, j = pos; i < tempSize; i++, j++)
		{
			this->operator[](j) = this->operator[](i);
		}

		return *this;
	}
	else
	{
		int tempSize(getSize());
		resize(pos);
		for (int i = pos; i < tempSize; i++)
		{
			this->operator[](i) = '\0';
		}

		return *this;
	}
}

size_t MyString::find(const MyString& str, size_t pos) const
{
	for (int i = pos; i < getSize(); i++)
	{
		int check = 0;
		if (this->operator[](i) == str[0])
		{
			check++;
			for (int j = 1; j < str.getSize(); j++)
			{
				if (this->operator[](i + j) == str[j])
				{
					check++;
				}
				else
				{
					break;
				}
			}
		}
		if (check == str.getSize())
		{
			return i;
		}
	}

	return msize;
}

size_t MyString::find_first_of(const MyString& str, size_t pos) const
{
	for (int i = pos; i < getSize(); i++)
	{
		for (int j = 0; j < str.getSize(); j++)
		{
			if (this->operator[](i) == str[j])
			{
				return i;
			}
		}
	}

	return msize;
}#ifndef S1081504_MyString_H
#define S1081504_MyString_H
#include <iostream>
#include <string>
#include "s1081504_MyArray.cpp"

using namespace std;

class MyString : public MyArray<char>
{
	friend ostream &operator<<(ostream& output, const MyString& str);
	friend istream &operator>>(istream& in, MyString& right);
public:

	MyString();
	MyString(const MyString& str);
	MyString(const MyString& str, size_t pos, size_t len = msize); 
	MyString(const char* s);
	~MyString();

	static const size_t msize = -1;

	MyString& append(const MyString& str);
	MyString substr(size_t pos, size_t len = msize) const;
	MyString& insert(size_t pos, const MyString& str);
	MyString& insert(size_t pos, const MyString& str, size_t subpos, size_t sublen = msize);
	MyString& erase(size_t pos, size_t len = msize);
	size_t find(const MyString& str, size_t pos = 0) const;
	size_t find_first_of(const MyString& str, size_t pos = 0) const;

};

#endif