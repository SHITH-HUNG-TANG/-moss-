#include"s1083305_MyArray.h"
using namespace std;

template<typename T>
MyArray<T>::MyArray(int Capacity)
{
	size = 0;
	capacity = Capacity;
	data = new T [capacity];
}

template<typename T>
MyArray<T>::MyArray(int Size, T value)
{
	size = Size;
	capacity = 10;
	while (capacity < size)
		capacity *= 2;
	data = new T [capacity];
	for (int i = 0; i < Size; i++) {
		data[i] = value;
	}
}

template<typename T>
MyArray<T>::MyArray(const MyArray<T>& n)
{
	size = n.size;
	capacity = n.capacity;
	data = new T[capacity];
	for (int i = 0; i < size; i++) {
		data[i] = n.data[i];
	}
}

template<typename T>
MyArray<T>::~MyArray()
{
	delete[] data;
}

template<typename T>
const MyArray<T>& MyArray<T>::operator=(const MyArray<T>& send)
{
	if (*this == send)
		return *this;
	size = send.size;
	capacity = send.capacity;
	delete[] data;
	data = new T[capacity];
	for (int i = 0; i < size; i++) {
		data[i] = send.data[i];
	}
	return *this;
}

template<typename T>
bool MyArray<T>::operator==(const MyArray<T>& send) const
{
	if (size != send.size)
		return false;
	if (capacity != send.capacity)
		return false;
	for (int i = 0; i < size; i++) {
		if (data[i] != send.data[i])
			return false;
	}
	return true;
}

template<typename T>
bool MyArray<T>::operator!=(const MyArray<T>& send) const
{
	if (*this == send)
		return false;
	else
		return true;
}

template<typename T>
MyArray<T> MyArray<T>::operator+(const MyArray<T>& send) const
{
	MyArray<T> ans(100);
	ans.size = size + send.size;
	ans.capacity = (capacity < send.capacity) ? send.capacity : capacity;
	while (ans.capacity < ans.size)
		ans.capacity *= 2;
	delete[] ans.data;
	ans.data = new T[ans.capacity];
	for (int i = 0; i < ans.size; i++) {
		ans.data[i] = (i < size) ? data[i] : send.data[i - size];
	}
	return ans;
}

template<typename T>
MyArray<T>& MyArray<T>::operator+=(const MyArray<T>& send)
{
	int a = size;
	size += send.size;
	if (capacity < send.capacity)
		capacity = send.capacity;
	while (capacity < size)
		capacity *= 2;
	reserve(capacity);
	for (int i = 0; i < send.size; i++) {  //還沒思考清楚
		data[i + a] = send.data[i];
	}
	return *this;
}

template<typename T>
T& MyArray<T>::operator[](int subscript)
{
	if (subscript < 0 || subscript >= size) {
		cerr << "\nError: Subscript " << subscript << " out of range\n";
		exit(1);
	}
	return data[subscript];
}

template<typename T>
T MyArray<T>::operator[](int subscript) const
{
	if (subscript < 0 || subscript >= size) {
		cerr << "\nError: Subscript " << subscript << " out of range\n";
		exit(1);
	}
	return data[subscript];
}

template<typename T>
T& MyArray<T>::at(int subscript)
{
	if (subscript < 0 || subscript >= size) {
		//throw wrongRange();
		cerr << "\nError: Subscript " << subscript << " out of range\n";
		exit(1);
	}
	else
		return data[subscript];
}

template<typename T>
T MyArray<T>::at(int subscript) const
{
	if (subscript < 0 || subscript >= size) {
		//throw wrongRange();
		cerr << "\nError: Subscript " << subscript << " out of range\n";
		exit(1);
	}
	else
		return data[subscript];
}

template<typename T>
int MyArray<T>::getSize() const
{
	return size;
}

template<typename T>
int MyArray<T>::getCapacity() const
{
	return capacity;
}

template<typename T>
void MyArray<T>::resize(size_t Sendsize, T item)
{
	int oldsize = size;
	MyArray<T> tem = *this;
	if (size > Sendsize) {
		size = Sendsize;
		delete[] data;
		data = new T[capacity];
		for (int i = 0; i < size; i++) {
			data[i] = tem.data[i];
		}
	}
	else { // size < 輸入值
		while (capacity < Sendsize) {
			capacity *= 2;
		}
		delete[] data;
		data = new T[capacity];
		size = Sendsize;
		for (int i = 0; i < size; i++) {
			if (i < oldsize)
				data[i] = tem.data[i];
			else
				data[i] = item;
		}
	}
}

template<typename T>
void MyArray<T>::reserve(size_t Sendcapacity)
{
	MyArray<T> tem = *this;
	capacity = Sendcapacity;
	delete[] data;
	data = new T[capacity];
	for (int i = 0; i < size; i++) {
		data[i] = tem.data[i];
	}
}

template<typename T>
void MyArray<T>::shrink_to_fit()
{
	MyArray<T> tem = *this;
	if (capacity > size)
		capacity = size;
	delete[] data;
	data = new T[capacity];
	for (int i = 0; i < size; i++) {
		data[i] = tem.data[i];
	}
}

template<typename T>
void MyArray<T>::clear()
{
	size = 0;
	delete[] data;
	data = new T[capacity];
}

template<typename T>
bool MyArray<T>::isEmpty() //
{
	if (size == 0)
		return true;
	else
		return false;
}

template class MyArray<char>;
template class MyArray<int>;
template class MyArray<string>;#pragma once
#include<iostream>
using namespace std;

template<typename T>
class MyArray {	//modify this class into a template class
	friend ostream& operator<<(ostream& os, const MyArray<T>& send) {
		for (int i = 0; i < send.size; i++) {
			cout << send.data[i];
			if (i != send.size)
				cout << ' ';
		}
		return os;
	}
	//friend istream& operator>>(istream&, MyArray&);
public:
	MyArray(int Capacity = 10);
	MyArray(int Size, T value);
	MyArray(const MyArray<T>&);
	~MyArray();

	const MyArray<T>& operator=(const MyArray<T>&);
	bool operator==(const MyArray<T>&) const;
	bool operator!=(const MyArray<T>&) const;
	MyArray<T> operator+(const MyArray<T>&) const;	//new
	MyArray<T>& operator+=(const MyArray<T>&);		//new
	T & operator[](int);
	T operator[](int) const;
	T& at(int);		//new
	T at(int) const;	//new

	int getSize() const;
	int getCapacity() const;
	//void resize(int item);
	void resize(size_t Sendsize, T item);
	void reserve(size_t Sendsize);
	void shrink_to_fit();	//new
	void clear();			//new
	bool isEmpty();			//new

private:
	int size;
	int capacity;
	T* data;
};

class wrongRange :public logic_error
{
public:
	wrongRange()
		:logic_error(" subscript out of range. ") {}

};#include"MyString_hw702.h"
#include<string>
MyString::MyString()
	:MyArray()
{
}

MyString::MyString(const MyString& str)
	:MyArray(str)
{
}

MyString::MyString(const MyString& str, size_t pos, size_t len)
	:MyArray(len,'\0')
{
	for (int i = pos; i < len + pos; i++) {
		at(i - pos) = str.at(i);
	}
}

MyString::MyString(const char* s)
{
	int p = 0;
	while (1) {
		if (s[p] == '\0')
			break;
		p++;
	 }
	this->resize(p, '\0');
	for (int i = 0; i < this->getSize(); i++) {
		at(i) = s[i];
	}
}

MyString::~MyString()
{
}

MyString& MyString::append(const MyString& str)
{
	MyString tmp = *this;
	int a = getSize() + str.getSize() + 1;
	resize(a, '\0');
	for (int i = 0; i < a; i++) {
		if (i < tmp.getSize())
			at(i) = tmp.at(i);
		else if (i == tmp.getSize())
			at(i) = ' ';
		else
			at(i) = str.at(i - tmp.getSize() - 1);
	}
	return *this;
}

MyString MyString::substr(size_t pos, size_t len) const
{
	int a = len;
	if (len + pos - 1 > getSize())
		a = getSize() - pos;
	MyString ans(*this,pos,a);
	return ans;
}

MyString& MyString::insert(size_t pos, const MyString& str)
{
	MyString tmp(*this,pos,getSize() - pos);
	resize(str.getSize() + getSize(), '\0');
	for (int i = pos; i < pos + str.getSize() + tmp.getSize(); i++) {
		if (i - pos < str.getSize())
			at(i) = str.at(i - pos);
		else
			at(i) = tmp.at(i - pos - str.getSize());
	}
	return *this;
}

MyString& MyString::insert(size_t pos, const MyString& str, size_t subpos, size_t sublen)
{
	MyString tmp = str.substr(subpos, sublen);
	insert(pos, tmp);
	return *this;
}

MyString& MyString::erase(size_t pos, size_t len)
{
	if (len < getSize()) {
		MyString tmp2(*this, pos + len, getSize() - pos - len);
		resize(getSize() - len, '\0');
		for (int i = pos; i < getSize(); i++) {
			at(i) = tmp2.at(i - pos);
		}
	}
	else {
		resize(pos, '\0');
	}
	return *this;
}

size_t MyString::find(const MyString& str, size_t pos) const
{
	string a, b;
	for (int i = 0; i < getSize(); i++) {
		a += at(i);
	}
	for (int i = pos; i < str.getSize(); i++) {
		b += str.at(i);
	}
	int ans = -1;
	for (int i = 0; i < a.length(); i++) {
		int j = 0;
		while (a[i + j] == b[j] && b[j] != '\0') {
			if (j == b.length() - 1)
				ans = i;
			j++;
		}
	}
	if (ans == -1) {
		return msize;
	}
	return ans;
}

size_t MyString::find_first_of(const MyString& str, size_t pos) const
{
	string a, b;
	for (int i = 0; i < getSize(); i++) {
		a += at(i);
	}
	for (int i = pos; i < str.getSize(); i++) {
		b += str.at(i);
	}
	int ans = -1;
	for (int i = 0; i < a.length(); i++) {
		int j = 0;
		for(int j = 0; j < b.length(); j++)
			if(a[i] == b[j])
				return i;
	}
	return msize;
}

ostream& operator<<(ostream& output, const MyString& str)
{
	for (int i = 0; i < str.getSize(); i++) {
		cout << str.at(i);
		//if (i != str.getSize())
		//	cout << ' ';
	}
	return output;
}
istream& operator>>(istream& input,  MyString& str)
{
	char* s = new char[100000];
	input >> s;
	int count = 0;
	while (s[count] != '\0')
		count++;
	str.resize(count, ' ');
	for (int i = 0; i < count; i++)
		str.at(i) = s[i];
	return input;
}