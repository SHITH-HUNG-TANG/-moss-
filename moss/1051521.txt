#include <iostream>
#include <vector>
#include "s1051521_MyArray.h"
using namespace std;

MyArray::MyArray() {
	capacity = 10;
	size = 0;
	sPtr = (char*)malloc(capacity + 1);
	*sPtr = '\0';
}

MyArray::MyArray(const MyArray &vec) {
	capacity = vec.capacity;
	size = vec.size;
	sPtr = (char*)malloc(capacity + 1);
	for (int i = 0; i < size; i++) {
		*(sPtr + i) = *(vec.sPtr + i);
	}
	*(sPtr + size) = '\0';
}

MyArray::~MyArray() {
	free(sPtr);
}

char* MyArray::begin() {
	return sPtr;
}

char* MyArray::end() {
	return sPtr + (capacity - 1);
}

size_t MyArray::getSize()const {
	return size;
}

void MyArray::resize(size_t n, char c) {
	if (n < size) {
		for (int i = n; i < size; i++)
			*(sPtr + i) = '\0';
	}
	else {
		reserve(n);
		for (int i = size; i < n; i++)
			*(sPtr + i) = c;
	}
	size = n;
}

size_t MyArray::getCapacity() const {
	return capacity;
}

void MyArray::reserve(size_t n) {
	if (n > capacity) {
		char *temp;
		temp = (char*)malloc(n + 1);
		for (int i = 0; i <= size; i++) {//'\0' need to be copy
			*(temp + i) = *(sPtr + i);
		}
		free(sPtr);
		sPtr = temp;
		capacity = n;
	}
}

void MyArray::shrink_to_fit() {
	if (size < capacity) {
		char *temp1;
		temp1 = (char*)malloc(size + 1);
		for (int i = 0; i <= size; i++) {
			*(temp1 + i) = *(sPtr + i);
		}
		free(sPtr);
		sPtr = temp1;
		capacity = size;
	}
}

void MyArray::clear() {
	*sPtr = '\0';
	size = 0;
}

bool MyArray::empty() const {
	if (size == 0)
		return true;
	else
		return false;
}

char& MyArray::front() {
	return *sPtr;
}

char& MyArray::back() {
	return *(sPtr + (size - 1));
}

void MyArray::push_back(char c) {
	*(sPtr + size) = c;
	*(sPtr + (size + 1)) = '\0';
	size++;
}

void MyArray::pop_back() {
	*(sPtr + (size - 1)) = '\0';
	size--;
}

char& MyArray::operator[] (size_t pos) {
	return *(sPtr + pos);
}

char MyArray::operator[] (size_t pos) const {
	return *(sPtr + pos);
}

bool MyArray::operator==(const MyArray &str) const {
	if (size != str.size)
		return false;
	for (int i = 0; i < size; i++) {
		if (*(sPtr + i) != *(str.sPtr + i))
			return false;
	}
	return true;
}

bool MyArray::operator!=(const MyArray &str) const {
	if (size != str.size)
		return true;
	for (int i = 0; i < size; i++) {
		if (*(sPtr + i) != *(str.sPtr + i))
			return true;
	}
	return false;
}

ostream &operator<<(ostream& output, const MyArray& vec) {
	vec.sPtr[vec.getSize()] = '\0';
	output << vec.sPtr;
	return output;
}#ifndef PG2CVector_H
#define PG2CVector_H
#include <iostream>
#include <vector>
using namespace std;

class MyArray
{
	friend ostream &operator<<(ostream& output, const MyArray& vec);

public:

	MyArray();
	MyArray(const MyArray &vec);
	~MyArray();

	char* begin();
	char* end();

	size_t getSize() const;
	void resize(size_t n, char c = '\0');
	size_t getCapacity() const;
	void reserve(size_t n = 0);
	void shrink_to_fit();
	void clear();
	bool empty() const;
	char& front();
	char& back();
	void push_back(char c);
	void pop_back();
	char& operator[] (size_t pos);
	char operator[] (size_t pos) const;
	bool operator==(const MyArray &str) const;
	bool operator!=(const MyArray &str) const;

private:
	size_t size;
	size_t capacity;
	char *sPtr;
};

#endif // !MyArray#include <iostream>
#include "s1051521_MyString.h"
using namespace std;

MyString::MyString() {

}

MyString::MyString(const MyString &str) : MyArray(str) {

}

MyString::MyString(const MyString &str, size_t pos, size_t len) : MyArray() {
	char ch;
	reserve(len);
	for (int i = 0; i < len; i++) {
		ch = str[pos + i];
		push_back(ch);
	}
}

MyString::MyString(const char *s) : MyArray() {
	reserve(strlen(s));
	while (*s != '\0') {
		push_back(*s);
		s++;
	}
}

MyString::~MyString() {

}

MyString &MyString::append(const MyString &str) {
	reserve(getSize() + str.getSize());

	char words;
	for (int i = 0; i < str.getSize(); i++) {
		words = str[i];
		push_back(words);
	}
	return *this;
}

MyString MyString::substr(size_t pos, size_t len) const {
	MyString x;
	char ch;
	x.reserve(len);
	for (int i = 0; i < len; i++) {
		ch = (*this)[pos + i];
		x.push_back(ch);
	}
	return x;
}

MyString &MyString::insert(size_t pos, const MyString &str) {
	reserve(getSize() + str.getSize());
	char x;
	MyString newstring(*this);
	resize(pos);
	for (int i = 0; i < str.getSize(); i++) {
		x = str[i];
		push_back(x);
	}
	for (int i = 0; i < newstring.getSize() - pos; i++) {
		x = newstring[pos + i];
		push_back(x);
	}
	return *this;
}

MyString &MyString::insert(size_t pos, const MyString &str, size_t subpos, size_t sublen) {
	reserve(getSize() + sublen);
	char ch;
	MyString newstring(*this);
	resize(pos);
	for (int i = 0; i < sublen; i++) {
		ch = str[subpos + i];
		push_back(ch);
	}
	for (int i = 0; i < newstring.getSize() - pos; i++) {
		ch = newstring[pos + i];
		push_back(ch);
	}
	return *this;
}

MyString &MyString::erase(size_t subpos, size_t sublen) {
	char ch;
	MyString newstring(*this);
	resize(subpos);
	for (int i = 0; i < newstring.getSize() - subpos - sublen; i++) {
		ch = newstring[subpos + sublen + i];
		push_back(ch);
	}
	return *this;
}

size_t MyString::find(const MyString &str, size_t pos) const {
	bool flag;

	for (int i = pos; i < (getSize() - str.getSize() + 1); i++) {
		flag = true;
		for (int k = 0; k < str.getSize(); k++) {
			if (str[k] != (*this)[i + k]) {
				flag = false;
				break;
			}
		}
		if (flag)
			return i;
	}
	return msize;
}

size_t MyString::find_first_of(const MyString &str, size_t pos) const {
	bool flag;

	for (int i = pos; i < getSize(); i++) {
		flag = false;
		for (int k = 0; k < str.getSize(); k++) {
			if (str[k] == (*this)[i]) {
				flag = true;
				break;
			}
		}
		if (flag)
			return i;
	}
	return msize;
}

MyString MyString::operator+ (const MyString& rhs) const {
	MyString x(*this);
	x.append(rhs);
	return x;
}

MyString MyString::operator+ (const char* rhs) const {
	MyString x(rhs);
	MyString y(*this);
	y.append(x);
	return y;
}

MyString operator+ (const char*lhs, const MyString& rhs) {
	MyString x(lhs);
	x.append(rhs);
	return x;
}

MyString &MyString::operator= (const MyString& str) {
	//MyString x(str);
	//return x;

	clear();
	reserve(str.getSize());
	for (int i = 0; i < str.getSize(); i++) {
		push_back(str[i]);
	}
	return *this;
}

MyString &MyString::operator= (const char* s) {
	clear();
	reserve(strlen(s));
	while (*s != '\0') {
		push_back(*s);
		s++;
	}
	return *this;
}

ostream &operator<<(ostream& output, const MyString& str) {
	output << static_cast<const MyArray &>(str);
	return output;
}#ifndef PG2MyString_H
#define PG2MyString_H
#include <iostream>
#include "s1051521_MyArray.h"
using namespace std;

class MyString : public MyArray
{
	friend ostream &operator<<(ostream& output, const MyString& str);

public:
	MyString();
	// Constructs an empty string, with a length of zero characters. 
	// *default capacity = 10

	MyString(const MyString &str);
	// Constructs a copy of "str". (copy constructor)

	MyString(const MyString &str, size_t pos, size_t len = msize); // (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).

	MyString(const char *s);
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	~MyString();
	// Destroys the string object.

	static const size_t msize = 999;
	//Note: maximum size.

	MyString& append(const MyString &str);
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos = 0, size_t len = msize) const;
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.

	MyString& insert(size_t pos, const MyString &str);
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert(size_t pos, const MyString &str, size_t subpos, size_t sublen);
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase(size_t subpos, size_t sublen);
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	size_t find(const MyString &str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

	size_t find_first_of(const MyString &str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.


	MyString operator+ (const MyString& rhs) const;
	MyString operator+ (const char*   rhs) const;
	friend MyString operator+ (const char*   lhs, const MyString& rhs);

	MyString& operator= (const MyString& str);
	MyString& operator= (const char* s);
}; // end class MyString

#endif#include <iostream>
#include <vector>
#include "s1051521_MyArray.h"
using namespace std;

MyArray::MyArray() {
	capacity = 10;
	size = 0;
	sPtr = (char*)malloc(capacity + 1);
	*sPtr = '\0';
}

MyArray::MyArray(const MyArray &vec) {
	capacity = vec.capacity;
	size = vec.size;
	sPtr = (char*)malloc(capacity + 1);
	for (int i = 0; i < size; i++) {
		*(sPtr + i) = *(vec.sPtr + i);
	}
	*(sPtr + size) = '\0';
}

MyArray::~MyArray() {
	free(sPtr);
}

char* MyArray::begin() {
	return sPtr;
}

char* MyArray::end() {
	return sPtr + (capacity - 1);
}

size_t MyArray::getSize()const {
	return size;
}

void MyArray::resize(size_t n, char c) {
	if (n < size) {
		for (int i = n; i < size; i++)
			*(sPtr + i) = '\0';
	}
	else {
		reserve(n);
		for (int i = size; i < n; i++)
			*(sPtr + i) = c;
	}
	size = n;
}

size_t MyArray::getCapacity() const {
	return capacity;
}

void MyArray::reserve(size_t n) {
	if (n > capacity) {
		char *temp;
		temp = (char*)malloc(n + 1);
		for (int i = 0; i <= size; i++) {//'\0' need to be copy
			*(temp + i) = *(sPtr + i);
		}
		free(sPtr);
		sPtr = temp;
		capacity = n;
	}
}

void MyArray::shrink_to_fit() {
	if (size < capacity) {
		char *temp1;
		temp1 = (char*)malloc(size + 1);
		for (int i = 0; i <= size; i++) {
			*(temp1 + i) = *(sPtr + i);
		}
		free(sPtr);
		sPtr = temp1;
		capacity = size;
	}
}

void MyArray::clear() {
	*sPtr = '\0';
	size = 0;
}

bool MyArray::empty() const {
	if (size == 0)
		return true;
	else
		return false;
}

char& MyArray::front() {
	return *sPtr;
}

char& MyArray::back() {
	return *(sPtr + (size - 1));
}

void MyArray::push_back(char c) {
	*(sPtr + size) = c;
	*(sPtr + (size + 1)) = '\0';
	size++;
}

void MyArray::pop_back() {
	*(sPtr + (size - 1)) = '\0';
	size--;
}

char& MyArray::operator[] (size_t pos) {
	return *(sPtr + pos);
}

char MyArray::operator[] (size_t pos) const {
	return *(sPtr + pos);
}

bool MyArray::operator==(const MyArray &str) const {
	if (size != str.size)
		return false;
	for (int i = 0; i < size; i++) {
		if (*(sPtr + i) != *(str.sPtr + i))
			return false;
	}
	return true;
}

bool MyArray::operator!=(const MyArray &str) const {
	if (size != str.size)
		return true;
	for (int i = 0; i < size; i++) {
		if (*(sPtr + i) != *(str.sPtr + i))
			return true;
	}
	return false;
}

ostream &operator<<(ostream& output, const MyArray& vec) {
	vec.sPtr[vec.getSize()] = '\0';
	output << vec.sPtr;
	return output;
}#ifndef PG2CVector_H
#define PG2CVector_H
#include <iostream>
#include <vector>
using namespace std;

class MyArray
{
	friend ostream &operator<<(ostream& output, const MyArray& vec);

public:

	MyArray();
	MyArray(const MyArray &vec);
	~MyArray();

	char* begin();
	char* end();

	size_t getSize() const;
	void resize(size_t n, char c = '\0');
	size_t getCapacity() const;
	void reserve(size_t n = 0);
	void shrink_to_fit();
	void clear();
	bool empty() const;
	char& front();
	char& back();
	void push_back(char c);
	void pop_back();
	char& operator[] (size_t pos);
	char operator[] (size_t pos) const;
	bool operator==(const MyArray &str) const;
	bool operator!=(const MyArray &str) const;

private:
	size_t size;
	size_t capacity;
	char *sPtr;
};

#endif // !MyArray#include <iostream>
#include "s1051521_MyString.h"
using namespace std;

MyString::MyString() {

}

MyString::MyString(const MyString &str) : MyArray(str) {

}

MyString::MyString(const MyString &str, size_t pos, size_t len) : MyArray() {
	char ch;
	reserve(len);
	for (int i = 0; i < len; i++) {
		ch = str[pos + i];
		push_back(ch);
	}
}

MyString::MyString(const char *s) : MyArray() {
	reserve(strlen(s));
	while (*s != '\0') {
		push_back(*s);
		s++;
	}
}

MyString::~MyString() {

}

MyString &MyString::append(const MyString &str) {
	reserve(getSize() + str.getSize());

	char words;
	for (int i = 0; i < str.getSize(); i++) {
		words = str[i];
		push_back(words);
	}
	return *this;
}

MyString MyString::substr(size_t pos, size_t len) const {
	MyString x;
	char ch;
	x.reserve(len);
	for (int i = 0; i < len; i++) {
		ch = (*this)[pos + i];
		x.push_back(ch);
	}
	return x;
}

MyString &MyString::insert(size_t pos, const MyString &str) {
	reserve(getSize() + str.getSize());
	char x;
	MyString newstring(*this);
	resize(pos);
	for (int i = 0; i < str.getSize(); i++) {
		x = str[i];
		push_back(x);
	}
	for (int i = 0; i < newstring.getSize() - pos; i++) {
		x = newstring[pos + i];
		push_back(x);
	}
	return *this;
}

MyString &MyString::insert(size_t pos, const MyString &str, size_t subpos, size_t sublen) {
	reserve(getSize() + sublen);
	char ch;
	MyString newstring(*this);
	resize(pos);
	for (int i = 0; i < sublen; i++) {
		ch = str[subpos + i];
		push_back(ch);
	}
	for (int i = 0; i < newstring.getSize() - pos; i++) {
		ch = newstring[pos + i];
		push_back(ch);
	}
	return *this;
}

MyString &MyString::erase(size_t subpos, size_t sublen) {
	char ch;
	MyString newstring(*this);
	resize(subpos);
	for (int i = 0; i < newstring.getSize() - subpos - sublen; i++) {
		ch = newstring[subpos + sublen + i];
		push_back(ch);
	}
	return *this;
}

size_t MyString::find(const MyString &str, size_t pos) const {
	bool flag;

	for (int i = pos; i < (getSize() - str.getSize() + 1); i++) {
		flag = true;
		for (int k = 0; k < str.getSize(); k++) {
			if (str[k] != (*this)[i + k]) {
				flag = false;
				break;
			}
		}
		if (flag)
			return i;
	}
	return msize;
}

size_t MyString::find_first_of(const MyString &str, size_t pos) const {
	bool flag;

	for (int i = pos; i < getSize(); i++) {
		flag = false;
		for (int k = 0; k < str.getSize(); k++) {
			if (str[k] == (*this)[i]) {
				flag = true;
				break;
			}
		}
		if (flag)
			return i;
	}
	return msize;
}

MyString MyString::operator+ (const MyString& rhs) const {
	MyString x(*this);
	x.append(rhs);
	return x;
}

MyString MyString::operator+ (const char* rhs) const {
	MyString x(rhs);
	MyString y(*this);
	y.append(x);
	return y;
}

MyString operator+ (const char*lhs, const MyString& rhs) {
	MyString x(lhs);
	x.append(rhs);
	return x;
}

MyString &MyString::operator= (const MyString& str) {
	//MyString x(str);
	//return x;

	clear();
	reserve(str.getSize());
	for (int i = 0; i < str.getSize(); i++) {
		push_back(str[i]);
	}
	return *this;
}

MyString &MyString::operator= (const char* s) {
	clear();
	reserve(strlen(s));
	while (*s != '\0') {
		push_back(*s);
		s++;
	}
	return *this;
}

ostream &operator<<(ostream& output, const MyString& str) {
	output << static_cast<const MyArray &>(str);
	return output;
}#ifndef PG2MyString_H
#define PG2MyString_H
#include <iostream>
#include "s1051521_MyArray.h"
using namespace std;

class MyString : public MyArray
{
	friend ostream &operator<<(ostream& output, const MyString& str);

public:
	MyString();
	// Constructs an empty string, with a length of zero characters. 
	// *default capacity = 10

	MyString(const MyString &str);
	// Constructs a copy of "str". (copy constructor)

	MyString(const MyString &str, size_t pos, size_t len = msize); // (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).

	MyString(const char *s);
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	~MyString();
	// Destroys the string object.

	static const size_t msize = 999;
	//Note: maximum size.

	MyString& append(const MyString &str);
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos = 0, size_t len = msize) const;
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.

	MyString& insert(size_t pos, const MyString &str);
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert(size_t pos, const MyString &str, size_t subpos, size_t sublen);
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase(size_t subpos, size_t sublen);
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	size_t find(const MyString &str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

	size_t find_first_of(const MyString &str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.


	MyString operator+ (const MyString& rhs) const;
	MyString operator+ (const char*   rhs) const;
	friend MyString operator+ (const char*   lhs, const MyString& rhs);

	MyString& operator= (const MyString& str);
	MyString& operator= (const char* s);
}; // end class MyString

#endif#include <iostream>
#include <vector>
#include "s1051521_MyArray.h"
using namespace std;

MyArray::MyArray() {
	capacity = 10;
	size = 0;
	sPtr = (char*)malloc(capacity + 1);
	*sPtr = '\0';
}

MyArray::MyArray(const MyArray &vec) {
	capacity = vec.capacity;
	size = vec.size;
	sPtr = (char*)malloc(capacity + 1);
	for (int i = 0; i < size; i++) {
		*(sPtr + i) = *(vec.sPtr + i);
	}
	*(sPtr + size) = '\0';
}

MyArray::~MyArray() {
	free(sPtr);
}

char* MyArray::begin() {
	return sPtr;
}

char* MyArray::end() {
	return sPtr + (capacity - 1);
}

size_t MyArray::getSize()const {
	return size;
}

void MyArray::resize(size_t n, char c) {
	if (n < size) {
		for (int i = n; i < size; i++)
			*(sPtr + i) = '\0';
	}
	else {
		reserve(n);
		for (int i = size; i < n; i++)
			*(sPtr + i) = c;
	}
	size = n;
}

size_t MyArray::getCapacity() const {
	return capacity;
}

void MyArray::reserve(size_t n) {
	if (n > capacity) {
		char *temp;
		temp = (char*)malloc(n + 1);
		for (int i = 0; i <= size; i++) {//'\0' need to be copy
			*(temp + i) = *(sPtr + i);
		}
		free(sPtr);
		sPtr = temp;
		capacity = n;
	}
}

void MyArray::shrink_to_fit() {
	if (size < capacity) {
		char *temp1;
		temp1 = (char*)malloc(size + 1);
		for (int i = 0; i <= size; i++) {
			*(temp1 + i) = *(sPtr + i);
		}
		free(sPtr);
		sPtr = temp1;
		capacity = size;
	}
}

void MyArray::clear() {
	*sPtr = '\0';
	size = 0;
}

bool MyArray::empty() const {
	if (size == 0)
		return true;
	else
		return false;
}

char& MyArray::front() {
	return *sPtr;
}

char& MyArray::back() {
	return *(sPtr + (size - 1));
}

void MyArray::push_back(char c) {
	*(sPtr + size) = c;
	*(sPtr + (size + 1)) = '\0';
	size++;
}

void MyArray::pop_back() {
	*(sPtr + (size - 1)) = '\0';
	size--;
}

char& MyArray::operator[] (size_t pos) {
	return *(sPtr + pos);
}

char MyArray::operator[] (size_t pos) const {
	return *(sPtr + pos);
}

bool MyArray::operator==(const MyArray &str) const {
	if (size != str.size)
		return false;
	for (int i = 0; i < size; i++) {
		if (*(sPtr + i) != *(str.sPtr + i))
			return false;
	}
	return true;
}

bool MyArray::operator!=(const MyArray &str) const {
	if (size != str.size)
		return true;
	for (int i = 0; i < size; i++) {
		if (*(sPtr + i) != *(str.sPtr + i))
			return true;
	}
	return false;
}

ostream &operator<<(ostream& output, const MyArray& vec) {
	vec.sPtr[vec.getSize()] = '\0';
	output << vec.sPtr;
	return output;
}#ifndef PG2CVector_H
#define PG2CVector_H
#include <iostream>
#include <vector>
using namespace std;

class MyArray
{
	friend ostream &operator<<(ostream& output, const MyArray& vec);

public:

	MyArray();
	MyArray(const MyArray &vec);
	~MyArray();

	char* begin();
	char* end();

	size_t getSize() const;
	void resize(size_t n, char c = '\0');
	size_t getCapacity() const;
	void reserve(size_t n = 0);
	void shrink_to_fit();
	void clear();
	bool empty() const;
	char& front();
	char& back();
	void push_back(char c);
	void pop_back();
	char& operator[] (size_t pos);
	char operator[] (size_t pos) const;
	bool operator==(const MyArray &str) const;
	bool operator!=(const MyArray &str) const;

private:
	size_t size;
	size_t capacity;
	char *sPtr;
};

#endif // !MyArray#include <iostream>
#include "s1051521_MyString.h"
using namespace std;

MyString::MyString() {

}

MyString::MyString(const MyString &str) : MyArray(str) {

}

MyString::MyString(const MyString &str, size_t pos, size_t len) : MyArray() {
	char ch;
	reserve(len);
	for (int i = 0; i < len; i++) {
		ch = str[pos + i];
		push_back(ch);
	}
}

MyString::MyString(const char *s) : MyArray() {
	reserve(strlen(s));
	while (*s != '\0') {
		push_back(*s);
		s++;
	}
}

MyString::~MyString() {

}

MyString &MyString::append(const MyString &str) {
	reserve(getSize() + str.getSize());

	char words;
	for (int i = 0; i < str.getSize(); i++) {
		words = str[i];
		push_back(words);
	}
	return *this;
}

MyString MyString::substr(size_t pos, size_t len) const {
	MyString x;
	char ch;
	x.reserve(len);
	for (int i = 0; i < len; i++) {
		ch = (*this)[pos + i];
		x.push_back(ch);
	}
	return x;
}

MyString &MyString::insert(size_t pos, const MyString &str) {
	reserve(getSize() + str.getSize());
	char x;
	MyString newstring(*this);
	resize(pos);
	for (int i = 0; i < str.getSize(); i++) {
		x = str[i];
		push_back(x);
	}
	for (int i = 0; i < newstring.getSize() - pos; i++) {
		x = newstring[pos + i];
		push_back(x);
	}
	return *this;
}

MyString &MyString::insert(size_t pos, const MyString &str, size_t subpos, size_t sublen) {
	reserve(getSize() + sublen);
	char ch;
	MyString newstring(*this);
	resize(pos);
	for (int i = 0; i < sublen; i++) {
		ch = str[subpos + i];
		push_back(ch);
	}
	for (int i = 0; i < newstring.getSize() - pos; i++) {
		ch = newstring[pos + i];
		push_back(ch);
	}
	return *this;
}

MyString &MyString::erase(size_t subpos, size_t sublen) {
	char ch;
	MyString newstring(*this);
	resize(subpos);
	for (int i = 0; i < newstring.getSize() - subpos - sublen; i++) {
		ch = newstring[subpos + sublen + i];
		push_back(ch);
	}
	return *this;
}

size_t MyString::find(const MyString &str, size_t pos) const {
	bool flag;

	for (int i = pos; i < (getSize() - str.getSize() + 1); i++) {
		flag = true;
		for (int k = 0; k < str.getSize(); k++) {
			if (str[k] != (*this)[i + k]) {
				flag = false;
				break;
			}
		}
		if (flag)
			return i;
	}
	return msize;
}

size_t MyString::find_first_of(const MyString &str, size_t pos) const {
	bool flag;

	for (int i = pos; i < getSize(); i++) {
		flag = false;
		for (int k = 0; k < str.getSize(); k++) {
			if (str[k] == (*this)[i]) {
				flag = true;
				break;
			}
		}
		if (flag)
			return i;
	}
	return msize;
}

MyString MyString::operator+ (const MyString& rhs) const {
	MyString x(*this);
	x.append(rhs);
	return x;
}

MyString MyString::operator+ (const char* rhs) const {
	MyString x(rhs);
	MyString y(*this);
	y.append(x);
	return y;
}

MyString operator+ (const char*lhs, const MyString& rhs) {
	MyString x(lhs);
	x.append(rhs);
	return x;
}

MyString &MyString::operator= (const MyString& str) {
	//MyString x(str);
	//return x;

	clear();
	reserve(str.getSize());
	for (int i = 0; i < str.getSize(); i++) {
		push_back(str[i]);
	}
	return *this;
}

MyString &MyString::operator= (const char* s) {
	clear();
	reserve(strlen(s));
	while (*s != '\0') {
		push_back(*s);
		s++;
	}
	return *this;
}

ostream &operator<<(ostream& output, const MyString& str) {
	output << static_cast<const MyArray &>(str);
	return output;
}#ifndef PG2MyString_H
#define PG2MyString_H
#include <iostream>
#include "s1051521_MyArray.h"
using namespace std;

class MyString : public MyArray
{
	friend ostream &operator<<(ostream& output, const MyString& str);

public:
	MyString();
	// Constructs an empty string, with a length of zero characters. 
	// *default capacity = 10

	MyString(const MyString &str);
	// Constructs a copy of "str". (copy constructor)

	MyString(const MyString &str, size_t pos, size_t len = msize); // (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).

	MyString(const char *s);
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	~MyString();
	// Destroys the string object.

	static const size_t msize = 999;
	//Note: maximum size.

	MyString& append(const MyString &str);
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos = 0, size_t len = msize) const;
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.

	MyString& insert(size_t pos, const MyString &str);
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert(size_t pos, const MyString &str, size_t subpos, size_t sublen);
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase(size_t subpos, size_t sublen);
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	size_t find(const MyString &str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

	size_t find_first_of(const MyString &str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.


	MyString operator+ (const MyString& rhs) const;
	MyString operator+ (const char*   rhs) const;
	friend MyString operator+ (const char*   lhs, const MyString& rhs);

	MyString& operator= (const MyString& str);
	MyString& operator= (const char* s);
}; // end class MyString

#endif