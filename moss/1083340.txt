#pragma once
#include<iostream>
#include<stdexcept>
#include<string>
using namespace std;

template<typename T>
class MyArray {	//modify this class into a template class
	friend ostream& operator<<(ostream& output, const MyArray& right)
	{
		for (int i = 0; i < right.size; i++)
			output << right.data[i] << " ";
		output << endl;
		return output;
	}
	//friend istream& operator>>(istream&, MyArray&);
public:
	MyArray()
	{
		size = 0;
		capacity = 10;
		data = new T[capacity]();
	}
	MyArray(int c)
	{
		size = (size <= 0) ? 0 : size;
		if (c <= 10)
			capacity = 10;
		else
			capacity = c;
		data = new T[capacity]();
	}
	MyArray(T s[], int value)
	{
		size = 0;
		int buf = size;
		data = new T[capacity]();
		resize(value ,'\0');
		for (int i = 0; i < value; i++)
			data[i + buf] = s[i];
	}
	MyArray(int s, T value)
	{
		size = 0;
		data = new T[capacity]();
		resize(s + size, value);
	}
	MyArray(const MyArray& right)
	{
		size = right.size;
		capacity = right.capacity;
		data = new T[capacity]();

		for (int i = 0; i < size; i++)
			data[i] = right.data[i];
	}
	~MyArray()
	{
		delete[] data;
	}
	
	const MyArray& operator=(const MyArray& right)
	{
		size = right.size;
		capacity = right.capacity;
		delete[] data;
		data = new T[capacity]();

		for (int i = 0; i < size; i++)
			data[i] = right.data[i];
		return *this;
	}
	bool operator==(const MyArray& right) const
	{
		if (size != right.size)
			return false;
		for (int i = 0; i < size; i++)
			if (data[i] != right.data[i])
				return false;
		return true;
	}
	bool operator!=(const MyArray& right) const
	{
		if (size == right.size)
		{
			for (int i = 0; i < size; i++)
			{
				if (data[i] != right.data[i])
					return true;
			}
			return false;
		}
		return true;
	}
	MyArray operator+(const MyArray& right) const
	{
		MyArray temp;
		temp.size = 0;
		int buf = size;
		temp.resize((size+right.size),'\0');
		for (int i = 0; i < buf; i++)
			temp.data[i] = data[i];
		for (int i = 0; i < right.size; i++)
			temp.data[i+buf] =right.data[i];
		return temp;
	}
	MyArray& operator+=(const MyArray& right)
	{
		int buf = size;
		int temp = right.size;
		resize((size+right.size),'\0');
		for (int i = 0; i < temp; i++)
			data[i+buf] = right.data[i];
		return *this;
	}
	T& operator[](T c)
	{
		if (c < 0 || c >= size)
		{
			cerr << "\nError: Subscript" << c << "out of range" << endl;
			exit(1);
		}
		return data[c];
	}
	T operator[](T c) const
	{
		if (c < 0 || c >= size)
		{
			cerr << "\nError: Subscript" << c << "out of range" << endl;
			exit(1);
		}
		return data[c];
	}
	T& at(int place)
	{
		if (place < size)
			return data[place];
		if(place>=size)
			throw out_of_range("check range");
	}
	T at(int place) const
	{
		if (place < size)
			return data[place];
		if (place >= size)
			throw out_of_range("check range");
	}
	int getSize() const
	{
		return size;
	}
	int getCapacity() const
	{
		return capacity;
	}
	void resize(size_t s, T item)
	{
		if (size > s)
		{
			size = s;
			return;
		}
		while (s > capacity)
			reserve(capacity*2);
		if (s > size )
			for (int i = size; i < s; i++)
				data[i] = item;
		size = s;
	}
	void reserve(size_t s)
	{
		if (s > capacity)
		{
			T* temp = new T[s]();
			for (int i = 0; i < size; i++)
				temp[i] = data[i];
			capacity = s;
			delete[] data;
			data = temp;
		}
	}
	void shrink_to_fit()
	{
		capacity = size;
	}
	void clear()
	{
		size = 0;
		data = new T[capacity]();
	}
	bool isEmpty()
	{
		if ((size == 0 || size==1) && data[0] == '\0')
			return true;
		return false;
	}

protected:
	int size=0;
	int capacity=10;
	T* data;
};

//#endif // !MyArray
#include <iostream>
#include <stdexcept>
#include <string>
#include"s1083440_MyString.h"
using namespace std;

ostream& operator<<(ostream& output, const MyString& str)
{
	for (int i = 0; i < str.size; i++)
		output << str.data[i] ;
	output << endl;
	return output;
}

istream& operator>>(istream& input, MyString& str)
{
	string ppp;
	input >> ppp;
	str.resize(ppp.size(), '\0');
	for (int i = 0; i < str.size; i++)
		str[i] = ppp[i];
	return input;
}

MyString::MyString():MyArray()
{
}

MyString::MyString(const MyString& str):MyArray(str)
{
}

const MyString &MyString::operator=(const MyString& str)
{
	size = str.size;
	capacity = str.capacity;
	delete[] data;
	data = new char[capacity]();

	for (int i = 0; i < size; i++)
		data[i] = str.data[i];
	return *this;
}

MyString::MyString(const MyString& str, size_t pos, size_t len)
{
	if (str.size <= (pos + 1))
	{
		throw out_of_range("check range");
	}
	else if ((str.size-pos) < len || len == msize)
	{
		for (int i = pos,k=0; i < str.size; i++,k++)
		{
			if ((size-pos) >= capacity)
				(*this).reserve(capacity * 2);
			data[k] = str.data[i];
			size++;
		}
	}
	else
	{
		for (int i = pos, k = 0; i < (len + pos); i++, k++)
		{
			if (size >= capacity)
				(*this).reserve(capacity * 2);
			data[k] = str.data[i];
			size++;
		}
	}
}

MyString::MyString(const char* s)
{
	data = new char[capacity]();
	size = 0;
	int i = 0;
	while (s[i] != '\0')
	{
		data[i] = s[i];
		size++;
		if (size >= capacity)
			(*this).reserve(capacity * 2);
		i++;
	}
}

MyString::~MyString()
{
}

MyString &MyString::append(const MyString& str)
{
	(*this) += str;
	return *this;
}

MyString MyString::substr(size_t pos, size_t len ) const
{
	MyString ppp;
	if (size <= (pos + 1))
	{
		throw out_of_range("check range");
	}
	else if ((size - pos) < len || len==msize)
	{
		for (int i = pos,k=0; i < size; i++,k++)
		{
			ppp.size++;
			ppp.resize(ppp.size, '\0');
			ppp.data[k] = data[i];
		}
	}
	else
	{
		for (int i = pos, k = 0; i < (len + pos); i++, k++)
		{
			ppp.size++;
			ppp.resize(ppp.size, '\0');
			ppp.data[k] = data[i];
		}
	}
	return ppp;
}

MyString& MyString::insert(size_t pos, const MyString& str)
{
	MyString ppp;
	ppp.resize((str.size + size), '\0');
	for (int i = 0; i < pos; i++)
		ppp[i] = (*this)[i];
	for (int i = 0; i < str.size; i++)
		ppp[i+pos] = str[i];
	for (int i = pos; i < size; i++)
		ppp[i+str.size] = (*this)[i];
	(*this) = ppp;
	return (*this);
}

MyString& MyString::insert(size_t pos, const MyString& str, size_t subpos, size_t sublen)
{
	MyString ppp;
	ppp=str.substr(subpos, sublen);
	MyString iii(*this);
	(*this)=iii.insert(pos, ppp);
	return (*this);
}

MyString& MyString::erase(size_t pos, size_t len)
{
	MyString ppp;
	if (size <= (pos + 1))
	{
		throw out_of_range("check range");
	}
	else if (len == msize || (size - pos) < len)
	{
		ppp.resize(size-(size - pos), '\0');
		for (int i = 0; i < pos; i++)
			ppp[i] = (*this)[i];
	}
	else
	{
		ppp.resize(size-len, '\0');
		for (int i = 0; i < pos; i++)
			ppp[i] = (*this)[i];
		for(int i=(pos+len-1);i<size;i++)
			ppp[i-len]=(*this)[i];
	}
	(*this) = ppp;
	return (*this);
}


int MyString::find(const MyString& str, size_t pos ) const
{
	int th = 0;
	signed int point1 = msize;
	for (int i = pos; i < size; i++)
	{
		if ((*this)[i] == str[0] && (size-i)>=str.size)
		{
			point1 = i;
			th++;
			for (int j = i + 1, k = 1; k < str.size; k++, j++)
			{
				if ((*this)[j] == str[k])
				{
					th++;
				}
				if ((*this)[j] != str[k])
				{
					th=0;
					point1 = msize;
					break;
				}
			}
		}
	}
	if (th == str.size)
		return point1;
	else
	{
		point1 = -1;
		return point1;
	}
}

int MyString::find_first_of(const MyString& str, size_t pos) const
{
	int point = msize;
	for (int i = pos; i < size; i++)
	{
		for (int j = 0; j < str.size; j++)
		{
			if ((*this)[i] == str[j])
			{
				point = i;
				return point;
			}
		}
	}
	return point;
}#ifndef MyString_H
#define MyString_H
#include <iostream>
#include <stdexcept>
#include <string>
#include "s1083340_MyArray.h"
using namespace std;

class MyString:public MyArray<char>
{
	friend ostream &operator<<(ostream& output, const MyString& str);
	friend istream &operator>>(istream& input, MyString& str);
public:
	MyString();
	// Constructs an empty string, with a length of zero characters. 
	// *default capacity = 10

	MyString(const MyString& str);
	// Constructs a copy of "str". (copy constructor)

	MyString(const MyString& str, size_t pos, size_t len = msize); // (substring constructor)
	// Copies the portion of str that begins at the character position "pos" and spans "len" characters 
	// (or until the end of str, if either str is too short or if len is string::msize).

	MyString(const char* s);
	// Copies the array of character (C-string) pointed by s.
	// The char *s is a pointer to a null-terminated sequence of characters. (all following char* are the same/)
	// The sequence is copied as the new value for the string.

	~MyString();
	// Destroys the string object.

	static const size_t msize = -1;
	//Note: maximum size. You may use SIZE_MAX at <cstdint>, too.

	MyString& append(const MyString& str);
	// Appends a str on the tail of current MyString. 
	// *Return the reference of itself

	MyString substr(size_t pos, size_t len = msize) const;
	// The substring is the portion of the object that starts at character position pos and spans len characters 
	// (or until the end of the string, whichever comes first).
	// *Returns a newly constructed string object with its value initialized to a copy of a substring of this object.

	MyString& insert(size_t pos, const MyString& str);
	// Inserts a copy of a str at "pos".
	// example: str = "to be question", str2 = "the "
	// str.insert(6,str2); 
	// = to be (the )question = to be the question
	// *Return the reference of itself

	MyString& insert(size_t pos, const MyString& str, size_t subpos, size_t sublen = msize);
	// Inserts a copy of a substring of str at "pos". The substring is the portion of "str" that
	// begins at the character position subpos and spans sublen characters (or until the end of str).
	// example: str = "to be the question", str3 = "or not to be"
	// str.insert(6,str3,3,4); // to be (not )the question
	// *Return the reference of itself

	MyString& erase(size_t pos, size_t len = msize);
	// Erases the portion of the string value that begins at the character position pos and spans len characters 
	// (or until the end of the string, if either the content is too short or if len is string::msize.)
	// *Return the reference of itself

	int find(const MyString& str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first occurrence of the string str.
	// Return Value: The position of the first character of the first match. If no matches were found, the function returns MyString::msize.

	int find_first_of(const MyString& str, size_t pos = 0) const;
	// Searches the portion of the string value that begins at the character position "pos" until the end of the string
	// for the first character that matches *any* of the characters of the string str.
	// Return Value: The position of the first character that matches. If no matches are found, the function returns MyString::msize.

	const MyString& operator=(const MyString& right);
}; // end class MyString

#endif