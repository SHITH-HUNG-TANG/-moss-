#include"s1081444_MyArray.h"

template<typename T>
ostream& operator<<(ostream &output, const MyArray<T> &a)
{
	for (int i = 0; i < a.size; ++i)
	{
		output << a.data[i];
		if (i < a.size - 1)
		{
			output << " ";
		}
	}
	return output;
}
template<typename T>
MyArray<T>::MyArray(int Capacity)
{
	size = 0;
	capacity = Capacity;
	data = new T[capacity]();
}
template<typename T>
MyArray<T>::MyArray(int Size, T value)
{
	size = Size;
	capacity = 10;
	data = new T[capacity]();
	while (size > capacity)
	{
		reserve(capacity * 2);
	}
	for (int i = 0; i < size; ++i)
	{
		data[i] = value;
	}
}
template<typename T>
MyArray<T>::MyArray(int Size, T* value)
{
	size = Size;
	capacity = 10;
	data = new T[capacity]();
	while (size > capacity)
	{
		reserve(capacity * 2);
	}
	for (int i = 0; i < size; ++i)
	{
		data[i] = value[i];
	}
}
template<typename T>
MyArray<T>::MyArray(const MyArray &copy)
{
	/*size = copy.size;
	capacity = copy.capacity;
	data = new T[capacity]();
	for (int i = 0; i < size; ++i)
	{
		data[i] = copy.data[i];
	}*/
	*this = copy;
}
template<typename T>
MyArray<T>::~MyArray()
{
	delete[] data;
}
template<typename T>
const MyArray<T>& MyArray<T>::operator=(const MyArray &right)
{
	size = right.size;
	capacity = right.capacity;
	data = new T[capacity]();
	for (int i = 0; i < size; ++i)
	{
		data[i] = right.data[i];
	}
	return *this;
}
template<typename T>
bool MyArray<T>::operator==(const MyArray &right) const
{
	if (size != right.size)
	{
		return false;
	}
	for (int i = 0; i < size; ++i)
	{
		if (data[i] != right.data[i])
		{
			return false;
		}
	}
	return true;
}
template<typename T>
bool MyArray<T>::operator!=(const MyArray &right) const
{
	return !(*this == right);
}
template<typename T>
MyArray<T> MyArray<T>::operator+(const MyArray &addend) const
{
	MyArray<T> temp1(*this);
	MyArray<T> temp2(addend);
	int i = temp1.size;
	temp1.size = temp1.size + temp2.size;
	while (temp1.size > temp1.capacity)
	{
		temp1.reserve(temp1.capacity * 2);
	}
	for (int j = 0; i < temp1.size; ++i, ++j)
	{
		temp1.data[i] = temp2.data[j];
	}
	return temp1;
}
template<typename T>
MyArray<T>& MyArray<T>::operator+=(const MyArray &right)
{
	MyArray<T> temp(right);
	int i = size;
	size += temp.size;
	while (size > capacity)
	{
		reserve(capacity * 2);
	}
	for (int j = 0; i < size; ++i, ++j)
	{
		data[i] = temp.data[j];
	}
	return *this;
}
template<typename T>
T& MyArray<T>::operator[](int index)
{
	return data[index];
}
template<typename T>
T MyArray<T>::operator[](int index) const
{
	return data[index];
}
template<typename T>
T& MyArray<T>::at(int index)
{
	if (index > size - 1)
	{
		throw out_of_range("");
	}
	else
	{
		return data[index];
	}
}
template<typename T>
T MyArray<T>::at(int index) const
{
	if (index > size - 1)
	{
		throw out_of_range("");
	}
	else
	{
		return data[index];
	}
}
template<typename T>
int MyArray<T>::getSize() const
{
	return size;
}
template<typename T>
int MyArray<T>::getCapacity() const
{
	return capacity;
}
template<typename T>
void MyArray<T>::resize(size_t s, T item)
{
	while (s > capacity)
	{
		reserve(capacity * 2);
	}
	if (s > size)
	{
		for (int i = size; i < s; ++i)
		{
			data[i] = item;
		}
	}
	size = s;
}
template<typename T>
void MyArray<T>::reserve(size_t n)
{
	if (n > capacity)
	{
		T *temp = new T[n]();
		for (int i = 0; (i < size) && (i < n); ++i)//i<n
		{
			temp[i] = data[i];
		}
		capacity = n;
		delete[] data;
		data = temp;
	}
}
template<typename T>
void MyArray<T>::shrink_to_fit()
{
	capacity = size;
	T *temp = new T[capacity]();
	for (int i = 0; i < size; ++i)
	{
		temp[i] = data[i];
	}
	delete[] data;
	data = temp;
}
template<typename T>
void MyArray<T>::clear()
{
	size = 0;
}
template<typename T>
bool MyArray<T>::isEmpty()
{
	return size == 0;
}#pragma once

#ifndef S1081444_MYARRAY_H
#define S1081444_MYARRAY_H

#include<iostream>
#include<stdexcept>
using namespace std;

template<typename T>
class MyArray
{
	friend ostream& operator<<(ostream &output, const MyArray<T> &a)
	{
		for (int i = 0; i < a.size; ++i)
		{
			output << a.data[i];
			if (i < a.size - 1)
			{
				output << " ";
			}
		}
		return output;
	}
public:
	MyArray(int Capacity = 10);
	MyArray(int Size, T value);
	MyArray(int Size, T* value);
	MyArray(const MyArray &);
	~MyArray();

	const MyArray& operator=(const MyArray &);
	bool operator==(const MyArray &) const;
	bool operator!=(const MyArray &) const;
	MyArray operator+(const MyArray &) const;
	MyArray& operator+=(const MyArray &);
	T &operator[](int);
	T operator[](int) const;
	T &at(int);
	T at(int) const;

	int getSize() const;
	int getCapacity() const;
	void resize(size_t size, T item);
	void reserve(size_t size);
	void shrink_to_fit();
	void clear();
	bool isEmpty();
private:
	int size;
	int capacity;
	T* data;
};

#endif#include"s1081444_MyString.h"

ostream& operator<<(ostream &output, const MyString &a)
{
	for (int i = 0; i < a.getSize(); ++i)
	{
		output << a[i];
	}
	return output;
}
istream& operator>>(istream &input, MyString &a)
{
	string s;
	getline(input, s);
	a.resize(s.size(), '\0');
	while (a.getSize() > a.getCapacity())
	{
		a.reserve(a.getCapacity() * 2);
	}
	for (int i = 0; i < a.getSize(); ++i)
	{
		a[i] = s[i];
	}
	return input;
}
MyString::MyString() :MyArray()
{

}
MyString::MyString(const MyString &str) : MyArray(str)
{

}
MyString::MyString(const MyString &str, size_t pos, size_t len)
{
	if (len == msize)
	{
		len = str.getSize() - pos;
	}
	resize(len,'\0');
	for (int i = 0, j = pos; i < getSize(); ++i, ++j)
	{
		this->operator[](i) = str[j];
	}
}
MyString::MyString(const char *s)
{
	int i;
	for (i = 0; s[i] != '\0'; ++i)
	{

	}
	resize(i, '\0');
	for (i = 0; s[i] != '\0'; ++i)
	{
		this->operator[](i) = s[i];
	}
}
MyString::~MyString()
{

}
static const size_t msize = -1;
MyString& MyString::append(const MyString &str)
{
	*this += str;
	return *this;
}
MyString MyString::substr(size_t pos, size_t len) const
{
	if (len == msize)
	{
		len = getSize() - pos;
	}
	return MyString(*this, pos, len);
}
MyString& MyString::insert(size_t pos, const MyString &str)
{
	/*MyString temp1 = substr(0, pos);
	MyString temp2 = substr(pos, getSize());
	MyString result = temp1.append(str).append(temp2);
	return *this = result;*/
	resize(getSize() + str.getSize(), '\0');
	return *this = substr(0, pos).append(str).append(substr(pos, getSize()));
}
MyString& MyString::insert(size_t pos, const MyString &str, size_t subpos, size_t sublen )
{
	if (sublen==msize)
	{
		sublen = str.getSize() - subpos;
	}
	resize(getSize() + sublen, '\0');
	return *this= substr(0, pos).append(str.substr(subpos,sublen)).append(substr(pos, getSize()));
}
MyString& MyString::erase(size_t pos, size_t len)
{
	if (len == msize)
	{
		len = getSize() - pos;
	}
	resize(getSize() - len, '\0');
	return *this = substr(0, pos).append(substr(pos + len, getSize()));
}
size_t MyString::find(const MyString &str, size_t pos) const
{
	bool found = false;
	int now = 0;
	for (int i = pos; i < getSize(); ++i)
	{
		if (this->operator[](i)==str[0])
		{
			now = i;
			for (int j = i,k=0; k < str.getSize(); ++j)
			{
				if (this->operator[](j) == str[k])
				{
					found = true;
				}
				else
				{
					found = false;
					break;
				}
				++k;
			}
			if (found)
			{
				break;
			}
		}
	}
	if (found)
	{
		return now;
	}
	else
	{
		return msize;
	}
}
size_t MyString::find_first_of(const MyString &str, size_t pos) const
{
	for (int i = pos; i < getSize(); ++i)
	{
		for (int j = 0; j < str.getSize(); ++j)
		{
			if (this->operator[](i) == str[j])
			{
				return i;
			}
		}
	}
	return msize;
}#pragma once

#ifndef S1081444_MYSTRING_H
#define S1081444_MYSTRING_H

#include"s1081444_MyArray.cpp"
#include<iostream>
#include<string>
using namespace std;

class MyString :public MyArray<char>
{
	friend ostream& operator<<(ostream &output, const MyString &a);
	friend istream& operator>>(istream &input, MyString &a);
public:
	MyString();
	MyString(const MyString &str);
	MyString(const MyString &str, size_t pos, size_t len = msize);
	MyString(const char *s);
	~MyString();

	static const size_t msize = -1;
	MyString& append(const MyString &str);
	MyString substr(size_t pos, size_t len = msize) const;
	MyString& insert(size_t pos, const MyString &str);
	MyString& insert(size_t pos, const MyString &str, size_t subpos, size_t sublen = msize);
	MyString& erase(size_t pos, size_t len = msize);
	size_t find(const MyString &str, size_t pos = 0) const;
	size_t find_first_of(const MyString &str, size_t pos = 0) const;
};

#endif